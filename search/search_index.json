{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"image/svg+xml ONETEP Tutorials 7.0.0 Introduction"},{"location":"#welcome-to-oneteps-tutorials","title":"Welcome to ONETEP's Tutorials!","text":"<p>This is a privately maintained repository of tutorials of ONETEP. The aim of this repository is to make the tutorial easier to read by including additional tutorials and using mkdocs.</p>"},{"location":"#contents","title":"Contents:","text":"<ul> <li>Tutorial 1: Setting up Simple ONETEP Calculations</li> <li>Tutorial 4: Geometry optimization </li> <li>Tutorial 5: DFT+U on strongly correlated magnetic materials: A case study on antiferromagnetic Hematite </li> <li>Tutorial 6: Time-Dependent DFT </li> <li>Tutorial 8: Implicit solvation, visualisation and properties: Protein-ligand free energy of binding for the T4 lysozyme </li> <li>Tutorial 9: Analysis and visualization </li> <li>Tutorial 10: Simulation cell relaxation</li> <li>Tutorial 11: Electrified electrode-electrolyte interfaces under potentiostatic control</li> <li>Tutorial 12: Quantum embedding with (time-dependent) embedded mean-field theory: hydrogenation and excitations of pentacene</li> <li>Tutorial 13: ASE ONETEP interface</li> <li>Tutorial 14: Electron Energy Loss Spectroscopy in ONETEP</li> </ul> image/svg+xml"},{"location":"tutorials/tutorial_1/tutorial/","title":"Tutorial 1","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 1"},{"location":"tutorials/tutorial_1/tutorial/#tutorial-1-simple-onetep-calculations","title":"Tutorial 1: Simple ONETEP Calculations","text":"<p> Version: all versions  Nicholas D.M. Hine; Chris-Kriton Skylaris </p>"},{"location":"tutorials/tutorial_1/tutorial/#input-files","title":"Input files","text":"<p>Setting up a ONETEP job involves creating a main input file with the suffix <code>.dat</code> (e.g., <code>your_system.dat</code>) which contains all the required information to describe both the system and the parameters of the job.</p> <p>This requires the user to provide input in the form of keywords and blocks. Keywords are written in the form: <pre><code>keyword: value [unit]\n</code></pre> For example, to specify that the task we wish the code to perform is a Single-Point energy calculation, we would add: <pre><code>task : SinglePoint\n</code></pre> to our input file.</p> <p>Note</p> <p>Capitalisation in the input file is irrelevant.</p> <p>If we wish to specify a cutoff energy of 500 eV for our standard grid, we would add: <pre><code>cutoff_energy : 500.0 eV\n</code></pre> The value in eV\u2019s will be converted internally to atomic units (Eh in this case). If a keyword is not specified in the input file, it is given a default value which is intended to work across a broad range of systems. A full list of keywords and blocks, giving their meaning, syntax and default values, can be found on the  ONETEP keyowrd database.</p> <p>Blocks are used to define the values of input parameters which need to contain multiple records, such as the definition of the unit cell. They take the form: <pre><code>%block blockname\na1 a2 a3\nb1 b2 b3\n\u2026\n%endblock blockname\n</code></pre> Most blocks tend not to have a meaningful default value, and must be specified if the related functionality is to be used. Comments can be added to input files using the <code>#</code>or<code>!</code> characters. Anything after these characters on a given line will be ignored.</p>"},{"location":"tutorials/tutorial_1/tutorial/#setting-up-the-input-file","title":"Setting up the Input File","text":"<p>We will start by running a simple job on a silane molecule SiH\\(_4\\). Create a working directory in which to run ONETEP: <pre><code>&gt; mkdir silane\n&gt; cd silane\n</code></pre> Create a new input file called silane.dat in your favourite text editor e.g. <pre><code>&gt; vi silane.dat\n</code></pre> You might like to put a comment at the top explaining what this input file is for e.g. <pre><code>! Simple ONETEP input file for a silane molecule\n</code></pre></p> <p>The first thing is to specify the simulation cell. The simplest choice is a cubic box with sides of about 40.0 Bohr. Enter the 3-component cell vectors, one per line, between the <code>%block lattice_cart</code> and <code>%endblock lattice_cart</code> keywords.</p> <pre><code>%block lattice_cart\n40.0 0.0 0.0\n0.0 40.0 0.0\n0.0 0.0 40.0\n%endblock lattice_cart\n</code></pre> <p>Second, the atomic species need to be specified, in this case silicon and hydrogen. This information needs to be provided between <code>%block species</code> and <code>%endblock species</code> keywords. In this block, we need to specify five pieces of information per species, separated by spaces (click on the <code>+</code> button to see the meaning of each piece):</p> <pre><code>%block species\n!(1) (2) (3) (4) (5)\n  Si  Si  14  4   6.0\n  H   H   1   1   6.0\n%endblock species\n</code></pre> <ol> <li>Your symbol for the atomic species     (this can be the same as the element symbol)</li> <li>The element symbol itself</li> <li>The atomic number Z</li> <li>The number of NGWFs per atom</li> <li>The NGWF radius.</li> </ol> <p>The number of NGWFs required can usually be judged from the symmetry of the atomic orbitals involved: In this case four for silicon and one for hydrogen will be adequate (can you think why?). For this molecule, 6.0 Bohr should be a reasonable starting point for the NGWF radii.</p> <p>Each atomic species in our calculation needs a pseudopotential file. The pseudopotential files are specified between <code>%block species_pot</code> and <code>%endblock species_pot</code> keywords. You can use the <code>hydrogen.recpot</code> and <code>silicon.recpot</code> files from the ONETEP pseudopotentials <code>pseudo</code> directory. Copy them to your working directory now (or make a symbolic link using <code>ln -s source destination</code>).</p> <pre><code>%block species_pot\nSi    \"PATH/TO/pseudo/silicon.recpot\"\nH     \"PATH/TO/pseudo/hydrogen.recpot\" !(1)!\n%endblock species_pot\n</code></pre> <ol> <li>Remember to change <code>PATH/TO</code> to the correct path to your potential files.</li> </ol> <p>Next, we need to specify the atomic positions, between <code>%block positions_abs</code> and <code>%endblock positions_abs</code> keywords. There is one line per atom. Remember to use your symbol for the atomic species as defined in the species block. The coordinates are assumed to be given in Bohr unless specified otherwise. While it is not requirement in ONETEP that all the atoms should lie within the simulation cell, it is best (for visualisation purposes) to start by placing the silicon atom at the centre of the cell. For SiH<sub>4</sub>, we can write: <pre><code>%block positions_abs\nSi 20.0000 20.0000 20.0000\nH  22.2535 21.5935 20.0000\nH  17.7465 21.5935 20.0000\nH  20.0000 18.4065 22.2535\nH  20.0000 18.4065 17.7465\n%endblock positions_abs\n</code></pre></p> <p> </p> Fig.1: structure of a SiH<sub>4</sub> molecule. <p>The last essential parameter to specify is the kinetic energy cutoff parameter for the PSINC basis set. A reasonable value to start with is 300 eV. Use the cutoff_energy keyword and remember to specify the energy unit as well as the value. <pre><code>cutoff_energy        : 300 eV\n</code></pre></p>"},{"location":"tutorials/tutorial_1/tutorial/#running-the-job","title":"Running the Job","text":"<p>Assuming the executable of ONETEP is located at <code>~/ONETEP/bin/onetep</code>, we can now run our job with: <pre><code>~/ONETEP/bin/onetep silane | tee silane.out\n</code></pre> Examine the output: if you have followed these instructions it should converge very quickly (8 iterations) to a total energy of around -6.1897 Eh.</p>"},{"location":"tutorials/tutorial_1/tutorial/#convergence","title":"Convergence","text":"<p>Just as in any form of traditional DFT, we must ensure that our calculation results are converged with respect to the size of the basis. In ONETEP, convergence with basis size is controlled by a small number of parameters, with respect to which the total energy is variational. In this context, that means the total energy at a given value of the parameter will be an upper bound to the true, converged total energy, and increasing the parameter will monotonically decrease the total energy, which asymptotically tends to its converged value.</p>"},{"location":"tutorials/tutorial_1/tutorial/#cutoff-energy","title":"Cutoff Energy","text":"<p>The first parameter will be familiar to anyone who has carried out plane-wave DFT calculations: the cutoff energy. This specifies the kinetic energy of the maximum G-vector of the reciprocal-space grid, and therefore the spacing of the real-space grid. With a 40 Bohr cell and a 300eV cutoff, ONETEP will have chosen a 48\\(\\times\\)48\\(\\times\\)48 grid, hence a grid spacing of 0.833 Bohr. This may be too coarse: move your old output file to a new name (e.g., <code>SiH4.out_Ec300</code>) and try changing the cutoff energy to 500eV, then re-run the job script. You may wish to add <code>output_detail: VERBOSE</code> to your input file, to see exactly what grids are being used at each cutoff.</p> <p>Comparing the two outputs, you should see that the total energy has decreased by around 0.03Eh (nearly 1eV, or 0.2 eV/atom). This suggests 300 eV was too low initially. Try increasing the cutoff in steps of 100 eV (You may wish to automate this, by having a loop in your job script in which the input file is updated and the job run for each update, if you are sufficiently familiar with bash scripting)</p> <p>Plot the total energy (\\(E_T\\)) as a function of cutoff energy. You should see a monotonic decrease in ET as a function of \\(E_{cut}\\): try to evaluate at what value you think the total energy is converged to about 0.1 eV/atom of its asymptotic limit. Note that the calculation time increases rapidly with cutoff energy, because the number of grid points in each FFTbox is growing rapidly with cutoff energy, and thus each FFT takes longer, so do not try going beyond around 1200 eV.</p> <p>In few cases in reality do we require strict convergence of the total energy. It is more usual that we require convergence of some measurable quantity such as a binding energy, which is based on energy differences. In that case, we do not require the total energy to be converged, only the difference between total energies of very similar systems. This may converge much faster than the total energy itself, presuming the same species are present in both systems. Always consider what it is that you need converging before you start running enormous calculations!</p>"},{"location":"tutorials/tutorial_1/tutorial/#ngwf-radius","title":"NGWF radius","text":"<p>Next, we will investigate convergence with respect to the NGWF radius. Pick a value of cutoff energy for which you can perform reasonably fast calculations (say, 500.0 eV) and try increasing the NGWF radius from 6.0 to 10.0 in 1.0 Bohr steps. Plot the total energy against NGWF radius. Again, you should see a monotonic decrease. Note that above 6.0 Bohr the FFT box is as large as the simulation cell, in a larger cell this would keep growing, and the calculation time would increase rapidly. Also, you should notice that the number of NGWF Conjugate Gradients iterations grows with the size of the localisation region, this is natural since with larger spheres there are more NGWF coefficients to simultaneously optimise. You may also wish to try converging with respect to the number of NGWFs per atom (eg try 9 NGWFs on the Silicon). In some systems, notably crystalline solids, this can be crucial to achieving good convergence of the NGWFs themselves.</p> <p>TODO</p> <ul> <li>add example script to do this.</li> <li>add plots.</li> </ul>"},{"location":"tutorials/tutorial_1/tutorial/#kernel-cutoff","title":"Kernel Cutoff","text":"<p>This SiH\\(_4\\) system is too small to investigate convergence with respect to the cutoff of the density kernel. In larger systems truncation of the density kernel can be a good way to speed up the calculation. Indeed, asymptotically it is only by truncating the kernel that true 'linear-scaling' behaviour of the computational effort will be observed.</p> <p>The kernel cutoff is controlled by the kernel_cutoff keyword. This defaults to 1000 Bohr (i.e. effectively infinite). Density kernel truncation should be used with a degree of caution: generally speaking, one would want to be able to run a full calculation for a fairly large system first, with an infinite cutoff, to establish a known baseline. Then, try decreasing the kernel cutoff from that point and see what the effect is on the total energy, on the level of NGWF convergence (as measured by the NGWF RMS gradient), and on the computation time. If significant time savings can be achieved without trading in too much accuracy, it may be worthwhile to bring down the cutoff for all similar calculations. Proceed with care, though as calculations with a truncated kernel tend to converge in a less stable manner.</p> <p>TODO</p> <ul> <li>add plots to illustrate the density matrix and the cutoff.</li> <li>add example script to do this.</li> <li>add plots for eonvergence.</li> </ul> image/svg+xml"},{"location":"tutorials/tutorial_10/tutorial/","title":"Tutorial 10","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 10"},{"location":"tutorials/tutorial_10/tutorial/#tutorial-10-simulation-cell-relaxation","title":"Tutorial 10: Simulation cell relaxation","text":"<p> Version: all versions  Chris-Kriton Skylaris </p>"},{"location":"tutorials/tutorial_10/tutorial/#introduction","title":"Introduction","text":"<p>This tutorial demonstrates how to Use ONETEP to relax the simulation cell of a crystalline material.</p>"},{"location":"tutorials/tutorial_10/tutorial/#cell-relaxation-of-bulk-crystalline-silica","title":"Cell relaxation of bulk crystalline silica","text":"<p>This calculation will relax the lattice of a silica (SiO<sub>2</sub>)  simulation cell, which is depicted below:</p> <p> </p>     Fig.1 The simulation cell of silica used     in this tutorial. The silicon atoms are     beige and the oxygen atoms are red."},{"location":"tutorials/tutorial_10/tutorial/#input-file-keywords","title":"Input file keywords","text":"<p>The input file, which is provided, is called \"silica96.dat\"  and contains 96 atoms in total.</p> <p>To perform cell relaxation the <code>task STRESS</code> keyword is required. </p> <p>You will notice in the input file also the following keywords  related to the cell relaxation:</p> <pre><code>  stress_tensor T\n  stress_elasticity F\n  stress_relax T\n  stress_assumed_symmetry tetra1\n  stress_relax_atoms T\n</code></pre> <p>Where <code>stress_tensor T</code> instructs the code to compute the  stress tensor, while the calculation of elestic constants is  trned off with <code>stress_elasticity F</code>. In this calculation  the  simulation cell will be relaxed (in order to determine the  optimal lattice vectors) and this is  denoted by <code>stress_relax T</code>.  In this calculation, in addition  to the simulation cell we want do relax also the coordinates  of the atoms and for this we use the keyword  <code>stress_relax_atoms T</code>. It is worth noting here that the  atomic coordinates would also be relaxed if the  <code>stress_relax_atoms</code> was set to <code>F</code> (False), but in this  case they would only be \"stretched\" to be commensurate  with the change in the lattice vectors, in other words  they would retain the same fractional coordinates.  On the other hand if the  <code>stress_relax_atoms</code> is activated the coordinates of the atoms are fully relaxed and are not  comstrained to remain equal to the fractional coordinates they had at the start of the calculation. </p> <p>Finally the <code>stress_assumed_symmetry tetra1</code> instructs the  code to assume a particular symmetry for the simulation cell  and maintain this symmetry during the cell relaxation.  Is the symmetry of the cell is known and is supported  by the code (see the user manual) is is important to  activate it with this keyword as it will significantly  reduce the number of single point energy calculations that  will be performed. </p>"},{"location":"tutorials/tutorial_10/tutorial/#running-the-calculation","title":"Running the calculation","text":"<p>Now run the calculation and examine the output.  Lets examine the output step by step noting the various stages  of the calculation.</p> <p>At the very beginning some information about the initialisation of the calculation is produced such as:</p> <ul> <li><code>PSINC grid sizes</code>: information about the grids used for the psinc basis functions</li> <li><code>Atom SCF Calculation for...</code>: here the code initialises the NGWFs with atomic orbitals created specificaly for the valence electrons of the chosen pseudopotentials and confined within the NGWF spherical regions.  </li> <li><code>STRESS: undistorted cell</code> : this is the beginning of the very first energy calculation from which calculations with applied stains will be subtracted to compute the stress tensor.</li> <li><code>Atomic positions optimised prior to stress calculation</code>: a geometry relaxation is performed first since we have specified stress_relax_atoms T</li> </ul> <p>You will notice that this calculation takes  30 NGWF iterations to converge as a very tight convergence  criterion for the NGWFs (<code>ngwf_threshold_orig 1.e-7</code>) has been applied in the input. This was done to ensure very accurate forces and it may be a bit extreme, but it is better to be on the safe side. </p> <p>After this energy evaluation the code computes the forces and compares them with the threshold that has been defined for geoemetry relaxation. In this calculation you will notice that the  forces are small and below the tolerance  (<code>|F|max 1.e-3 Eh/Bohr</code>) that has been set for the convergence of the  geometry. As a result the code reports that the geoemetry relaxation has been completed with the  message <code>Geometry optimization completed successfully</code>.</p>"},{"location":"tutorials/tutorial_10/tutorial/#calculation-of-the-stress-tensor","title":"Calculation of the stress tensor","text":"<p>Then the calculation proceeds to evaluate the energy of the  system at different distortions (strains) of  the lattice vectors in  order to compute the stress tensor.  The beginning of this procedure is denoted  by the <code>STRESS: distorted cells</code> message.</p> <p>The stress tensor computed is summarised at the end  of the first iteration of cell relaxation:</p> <pre><code>stress_tensor:  iteration   1\n</code></pre> <p>This stress tensor is now used to change the simulation cell. Again a geometry relaxation is performed which converges at  the first step.  Then several single point energy calculations  follow to compute a new stress tensor until we obtain  the summary  of the second iteration:</p> <pre><code>stress_tensor:  iteration   2\n</code></pre> <p>Finally, we see that in the third iteration the cell has been  relaxed. The relaxed cell is printed:</p> <pre><code>Relaxed cell:\n  bohr\n19.07668106     0.00000000      0.00000000\n0.00000000     19.07668106      0.00000000\n0.00000000      0.00000000     27.83315074\n</code></pre> <p>This completes tutorial 10.</p>"},{"location":"tutorials/tutorial_10/tutorial/#input-file","title":"Input file","text":"<ul> <li>T10_files.zip</li> </ul> image/svg+xml"},{"location":"tutorials/tutorial_11/tutorial/","title":"Tutorial 11","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 11"},{"location":"tutorials/tutorial_11/tutorial/#tutorial-11-electrified-electrode-electrolyte-interfaces-under-potentiostatic-control","title":"Tutorial 11: Electrified electrode-electrolyte interfaces under potentiostatic control","text":"<p> Version: all versions  Brad Ayers; Arihant Bhandari </p>"},{"location":"tutorials/tutorial_11/tutorial/#introduction","title":"Introduction","text":"<p>This tutorial endeavours to provide a comprehensive and illustrative example, highlighting ONETEP's ability to conduct potentiostatic calculations through the utilisation of a grand canonical DFT algorithm <sup>4</sup>. Alongside this written tutorial we have provided a Jupyter notebook that will guide you through the process of setting up and analysing a potentiostatic calculation.</p> <p>Moreover, this tutorial will demonstrate the feasibility of conducting these calculations within a solvent and electrolyte medium, employing the Fisicaro soft-sphere continuum model <sup>2</sup>  for solvation and the neutralisation via the grand canonical electrolyte (NECS) model <sup>1</sup>.</p>"},{"location":"tutorials/tutorial_11/tutorial/#setting-up-the-calculations","title":"Setting up the calculations","text":"<p>We will begin this tutorial by creating lithium surfaces using a tool of your preference. For the purpose of illustration, we have employed the ASE <sup>3</sup> to generate a 10-layer BCC [100] lithium surface. This can be simply visualised within the provided Jupyter notebook, and will look as follows:</p> <p></p> <p>Notably, in this tutorial, we've chosen a (3x3x10) supercell with a 50 \u00c5 vacuum in total, a decision that allows us to employ 9 Bohr NGWF radii, whilst ensuring ample volume for sufficient electrolyte to neutralise our surface.</p>"},{"location":"tutorials/tutorial_11/tutorial/#input-files","title":"Input files","text":"<p>For the purposes of this tutorial ONETEP will require only two files to work:</p> <ol> <li>A .dat file, which contains all the information about your system (Atomic positions &amp; Lattice vectors), as well your simulation parameters.</li> <li>A Pseudopotential file, here we will employ the Norm-conserving on the fly generated CASTEP ones, but this is up to the users discretion.</li> </ol> <p>Both of the aforementioned files, as well as a few output files can be downloaded below:</p> <ul> <li>Keywords.dat</li> <li>Li_surface.out</li> <li>Li_surface.dat</li> <li>T11_workbook.ipynb</li> <li>Li_NCP19_PBE_OTF.usp</li> </ul> <p>Note that the output files required for the visualisation section of this tutorial will have to generated by the user themselves, and will need to be copied to the same directory as the Jupyter notebook.</p> <p>Furthermore, Li_surface.dat is the .dat file used for your job submission, and Keywords.dat is simply the keywords that are taken in by the ASE script to generate said Li_surface.dat file.</p>"},{"location":"tutorials/tutorial_11/tutorial/#the-dat-file","title":"The Dat file","text":""},{"location":"tutorials/tutorial_11/tutorial/#grand-canonical-parameters","title":"grand canonical Parameters","text":"<p>Upon opening the provided Li.dat file, you will encounter the standardx parameters that ONETEP users are already familiar with: <code>Task</code>, <code>Cutoff_energy</code>, <code>Lattice_cart</code>, and <code>Positions_frac</code>. </p> <p>However, after these, a new section of interest awaits, aptly named:</p> <pre><code>   grand canonical Parameters\n   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n   edft_grand_canonical T             \n   edft_reference_potential -1.20 eV  \n   edft_electrode_potential  0.20  V  \n</code></pre> <p>Within the grand canonical formalism in ONETEP, there are two  main parameters of interest:</p> <ol> <li>Chemical Potential of the Reference Electrode</li> </ol> <p>Represented as \\(\\mu_{\\mathrm{e}}^{\\mathrm{ref}}\\), this value (-1.20 eV in this example) corresponds to the reference electrode's chemical potential. It serves as the benchmark against which all applied potentials are measured.</p> <ol> <li>Applied Potential to the Working Electrode</li> </ol> <p>In this case, a potential of 0.20 volts (\\(U\\)) is applied to the working electrode, giving us a working electrode potential of -1.40 eV (\\(\\mu_{\\mathrm{e}}\\)).</p> <p>These parameters find application in the following equations:</p> <ul> <li>Chemical Potential of the Working Electrode ($\\mu_{\\mathrm{e}}):</li> </ul> \\[       \\mu_{\\mathrm{e}} = \\mu_{\\mathrm{e}}^{\\mathrm{ref}} - e \\cdot U \\] <ul> <li>Number of Electrons (\\(N_e\\)):</li> </ul> \\[       N_e = \\sum_i f_i = \\sum_i \\frac{1}{1 + \\exp{\\left(\\beta(\\epsilon_i - \\mu_e)\\right)}} \\] <ul> <li>Charge on the System (\\(q\\)):</li> </ul> \\[       q = Z_{\\mathrm{ion}} - e \\cdot N_{e} \\] <p>Hence, by defining the applied potential and reference electrode potential, we can establish the chemical potential of the working electrode. It is worth noting here that only with zero applied potential (\\(U = 0\\)) and the reference value set to the potential of zero charge (\\(\\mu_{\\mathrm{e}}^{\\mathrm{ref}} = \\mu_{\\mathrm{e}}^{\\mathrm{PZC}}\\)) will we get zero charge on the system (\\(q = 0\\)).</p> <p>As a result, we gain the ability to compute the number of electrons within our system using the Fermi-Dirac distribution. Where, \\(\\epsilon\\)  corresponds to the eigenvalues of the KS-equations, and \\(\\mu_{\\mathrm{e}}\\)  is the chemical potential of our working electrode. Thereby allowing us to accurately calculate the charge present in the quantum system for a given applied potential.</p> <p>For a more detailed explanation of the grand canonical formalism, please refer to <sup>4</sup>.</p>"},{"location":"tutorials/tutorial_11/tutorial/#solvation-parameters","title":"Solvation Parameters","text":"<p>This section will highlight some of the more unintuitive parameters that are required to conduct a solvated calculation. They will be presented in the order in which they appear in the data file as done for the grand canonical parameters above.</p> <p>This block will highlight the solvation parameters themselves, with the following block highlighting the solvent parameters</p> <pre><code>   is_include_apolar T                 # Enables solvent-accessible surface-area (SASA) approximation\n   is_smeared_ion_rep T                # Enables the smeared ion representation due to multigrid solver\n   is_implicit_solvent T               # Enables the solvation model\n   is_solvation_properties T           # Provides extra properties i.e. electrolyte concentration\n   is_dielectric_function soft_sphere  # Utilising the Fisicaro soft-sphere model\n</code></pre> <p>For a much more detailed overview of each key parameter and its function, please refer to the documentation here: Solvent and Electrolyte model. </p> <p>For the solvent itself we have the following parameters:</p> <pre><code>   is_bulk_permittivity 90.7           # permitivity value of our solvent        (ethylene carbonate in this case)          \n   is_solvent_surf_tension 0.0506 N/m  # Surface tension of the selected solvent (ethylene carbonate in this case)      \n</code></pre> <p>Obviously these values will vary depending on the solvent of choice, and can be found in the literature.</p>"},{"location":"tutorials/tutorial_11/tutorial/#electrolyte-parameters","title":"Electrolyte Parameters","text":"<pre><code>   is_pbe                 full        # Enables the poison-boltzmann solver for electrolyte calculations\n   is_pbe_bc_debye_screening T        # Enables the Debye screening boundary condition\n   is_pbe_temperature   298.15        # Sets the temperature of the Boltzmann ions \n   is_pbe_neutralisation_scheme counterions_auto\n</code></pre> <p>The above parameters are required to conduct electrolyte calculations, and are fairly self-explanatory. However, it is worth noting that there are several neutralisation schemes available, and the one chosen here is recommended for most cases.</p> <p>Additionally, the following parameters are required by DL_MG to conduct the multigrid calculations:</p> <pre><code>   mg_max_res_ratio 1000.0\n   mg_max_iters_vcycle 500\n   mg_max_iters_newton 300\n   mg_vcyc_smoother_iter_pre 4\n   mg_vcyc_smoother_iter_post 4\n</code></pre> <p>These parameters are fairly ubiquitous, and are not expected to change between calculations. For further information, please refer to the documentation here: DL_MG.</p> <p>lastly, we have the following ions block, that define our electrolytes and their concentrations:</p> <pre><code>   %BLOCK SOL_IONS\n   Li    +1 1.0 # all concentrations are in Molar\n   PF6   -1 1.0\n   %ENDBLOCK SOL_IONS\n</code></pre> <p>Note that additional blocks can be added here to further adapt the model such as defining the soft-sphere radii of your system. </p>"},{"location":"tutorials/tutorial_11/tutorial/#analysis","title":"Analysis","text":"<p>Now that we have established the parameters required to conduct a solvated calculation, we can proceed to analyse the results obtained from either your own calculations or the provided ones.</p> <p>The first file of interest is the <code>Li.out</code> file, which contains the usual ONETEP output you might be familiar with, but will include additional that are of interest to us.  Firstly within CG-DFT inner loop, we can find the following:</p> <pre><code>   Iter                              Commutator    Grand pot.(L=E-TS-muN)  DeltaL\n     # 2                          0.000001192422   -1269.59513707094357  -2.05E-12\n\n   Step                       =       0.000010819110\n   Energy (E)                 =   -1297.517766665092\n   Entropy (-TS)              =      -0.065437957621\n   Chemical potential (-muN)  =      27.988067551769\n   Grand potential(L=E-TS-muN)=   -1269.595137070944\n   Est. 0K Energy 0.5*(E+L)   =   -1283.556451868018\n   Charge on quantum system   =      -3.995764707545\n   Residual Non-orthogonality =      -0.000000000000\n</code></pre> <p>If users are familiar with the canonical inner loop printing this will look familiar, however, there are a few key differences:</p> <ul> <li>Grand Potential (\\(L=E-TS-\\mu_{\\mathrm{e}}N\\)):</li> </ul> <p>This is the grand potential of the system, and is the quantity that is minimised in the grand canonical formalism,    rather than the Helmholtz free energy as in the canonical formalism.</p> <ul> <li>Chemical Potential of the Working Electrode (\\(-\\mu_{\\mathrm{e}}N\\)):</li> </ul> <p>This is the chemical potential of the working electrode, and is the quantity that is constant in the grand canonical formalism,    in direct contrast to the canonical formalism, where the number of electrons is constant.</p> <ul> <li> <p>Charge on the System (\\(q\\)): </p> <p>This is the charge on the quantum system and is an important value to consider when analysing the results of a potentiostatic calculation, as surface chemistry is dependent on the charge of one's system.</p> </li> </ul> <p>Another crucial section of the <code>Li.out</code> file is the bulk concentration of the electrolyte species, which can be found in the following section:</p> <pre><code>    +--------------------------- Chemical potential --------------------------+\n    |   # | Name | Bulk conc. |    mu_ideal   |   mu_excess   |    mu_total   |\n    |-------------------------------------------------------------------------|\n    |   1 |   Li |  2.1511516 |   0.000723249 |  -0.000320109 |   0.000403139 |\n    |   2 |  PF6 |  0.7473276 |  -0.000274995 |  -0.000128144 |  -0.000403139 |\n    |-------------------------------------------------------------------------|\n\n    +----------------- Boltzmann ion concentration and charge -----------------+\n    |   # | Name | Bulk conc. | Average conc. | Neutr. ratio |    Total charge |\n    |--------------------------------------------------------------------------|\n    |   1 |   Li |  2.1511516 |   2.151153746 |     0.820011 |     6.122921628 | \n    |   2 |  PF6 |  0.7473276 |   0.747327832 |     0.179989 |    -2.127151420 | \n    +--------------------------------------------------------------------------+\n                                                        total:     3.995770208*\n</code></pre> <p>This tells the user the bulk concentration of each species required to neutralise the surface. Note however as this is a grand canonical neutralisation we can have average concentrations greater than 1M. This is due to grand canonical neutralisation alowing for a changing number of species in the system, ensuring that the surface is neutralised at all times.</p> <p>A final note here is as our calculations are performed within in solvent &amp; electrolyte additional energy components are added to the energy breakdown printed at the end our calculations:</p> <pre><code>   ---------------- ENERGY COMPONENTS (Eh) ----------------\n   | Kinetic                    :      937.59573135429741 |\n   | Pseudo. (local,PBC,corr'd) :     -443.84297910438869 |\n   | Pseudopotential (non-local):     -714.75069598392804 |\n   | Hartree (molecular)        :       41.93332431044017 |\n   | Exchange-correlation       :     -300.25087260634427 |\n   | Ewald                      :    20583.02565243620480 |\n   | Dispersion Correction      :       -0.65678636433385 |\n   | Smeared ion non-self corr. :   -20592.71568368581570 | \n   | Smeared ion self corr.     :     -807.85811781290136 |\n   | Solvent cavitation energy  :        0.02783765502215 |\n   | Solute-solvent dis-rep en. :       -0.02001318613680 |\n   | Elect. mobile ion energy   :       -0.00262591694826 |\n   | Osmotic pressure energy    :       -0.00778959415557 |\n   | Acc. corr. (steric) energy :        0.00044786192622 |\n   | Ionic atmo. rearrang. en.  :        0.00641482442191 |\n   | Chemical pot. contribution :       -0.00161085245160 |\n   | Total                      :    -1297.51776666508886 |\n   |------------------------------------------------------|\n   | Entropic contribution      :       27.92262959414529 |\n   | Total free energy          :    -1269.59513707094357 |\n   --------------------------------------------------------\n   ------ LOCAL ENERGY COMPONENTS FROM MATRIX TRACES ------\n   | Pseudopotential (local)    :     -443.84297910438886 |\n   | Hartree                    :      -24.92214858378443 |\n   --------------------------------------------------------\n   |Integrated density          :      543.99576470754505 |\n   |Integrated spin density     :        0.00000000000165 |\n   |Integrated |spin density|   :        0.00000001531685 | \n   |Local density approx. &lt;S^2&gt; :        0.00000000765765 |\n   |Integrated density tr(KS)   :      543.99576470754528 |\n   |Integrated spin tr(KS)      :        0.00000000000153 |\n   --------------------------------------------------------\n</code></pre> <p>We won't delve into the details of each energy component here, but it is worth noting that the solvent and electrolyte contributions are present in the energy breakdown. For a more detailed explanation of each energy component, please refer to <sup>4</sup>.</p>"},{"location":"tutorials/tutorial_11/tutorial/#visualisation","title":"visualisation","text":"<p>Whilst a majority of the analysis can be conducted using the <code>Li.out</code> file provided, there are a few visualisations that can be conducted using the user generated <code>Li_out_bion_conc_species_1.dx</code> and <code>Li_out_bion_conc_species_2.dx</code> files.  Such as plotting the xy-averaged concentration profiles of the electrolyte species, it is worth stating that all code used to generate these plots can be found in the provided Jupyter notebook.</p> <p></p> <p>Looking at the figure above we can see that the concentration of the lithium electrolyte species is highest (12M) at the surface of the electrode, and decreases as we move away from the surface, forming a double layer along our surface. In contrary we can observe the PF6 electrolyte species has a concentration approaching 0M at the surface, and increases as we move away from the surface, note that these are local concentrations and not bulk concentrations.</p> <p>We can also visualise the densities of our lithium slab and the electrolyte species to illusrate this double layer effect by adding the <code>Li_out_bion_density_total.dx</code> and <code>Li_in_rho.dx</code> files together and running the provided code:</p> <p></p> <p>Here we can see that there is a positive charge denisty (our lithium ions) at the surface of the electrode, that diffuses in intensity as we move away from the surface.</p>"},{"location":"tutorials/tutorial_11/tutorial/#where-to-go-next","title":"Where to go next?","text":"<p>This tutorial has provided a brief overview of the grand canonical formalism, and how it can be employed to conduct potentiostatic calculations,  as well as highlighting a few key visualisation techniques that can be conducted on the output files.</p> <p>However, there are a few key areas that have not been covered in this tutorial that the reader should explore, such as:</p> <ol> <li>Defining their reference potentials (\\(\\mu_{\\mathrm{e}}^{\\mathrm{ref}}\\)):</li> </ol> <p>In this tutorial, we have defined the reference potential as -1.20 eV, however, this value is dependent on the reference electrode of choice,     and can be found in the literature or by calculating one's own reference potential using the method highlighted in <sup>4</sup>.</p> <ol> <li>Cycling through potentials:</li> </ol> <p>In this tutorial, we have only conducted a single potentiostatic calculation, however, it is possible to conduct a series of calculations at different potentials,     and calculate properties such as capacitance etc. </p>"},{"location":"tutorials/tutorial_11/tutorial/#references","title":"References","text":"image/svg+xml <ol> <li> <p>Bhandari, A.; Anton, L.; Dziedzic, J.; Peng, C.; Kramer, D.; Skylaris, C.-K. Electronic Structure Calculations in Electrolyte Solutions: Methods for Neutralization of Extended Charged Interfaces. The Journal of Chemical Physics 2020, 153 (12), 124101. https://doi.org/10.1063/5.0021210.\u00a0\u21a9</p> </li> <li> <p>Fisicaro, G.; Genovese, L.; Andreussi, O.; Mandal, S.; Nair, N. N.; Marzari, N.; Goedecker, S. Soft-Sphere Continuum Solvation in Electronic-Structure Calculations. Journal of Chemical Theory and Computation 2017, 13 (8), 3829\u20133845. https://doi.org/10.1021/acs.jctc.7b00375.\u00a0\u21a9</p> </li> <li> <p>Hjorth Larsen, A.; J\u00f8rgen Mortensen, J.; Blomqvist, J.; Castelli, I. E.; Christensen, R.; Du\u0142ak, M.; Friis, J.; Groves, M. N.; Hammer, B.; Hargus, C.; Hermes, E. D.; Jennings, P. C.; Bjerre Jensen, P.; Kermode, J.; Kitchin, J. R.; Leonhard Kolsbjerg, E.; Kubal, J.; Kaasbjerg, K.; Lysgaard, S.; Bergmann Maronsson, J. The Atomic Simulation Environment\u2014a Python Library for Working with Atoms. Journal of Physics: Condensed Matter 2017, 29 (27), 273002. https://doi.org/10.1088/1361-648x/aa680e.\u00a0\u21a9</p> </li> <li> <p>Bhandari, A.; Peng, C.; Dziedzic, J.; Anton, L.; Owen, J. R.; Kramer, D.; Chris-Kriton Skylaris. Electrochemistry from First-Principles in the grand canonical Ensemble. Journal of Chemical Physics 2021, 155 (2). https://doi.org/10.1063/5.0056514.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_12/tutorial/","title":"Tutorial 12","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 12"},{"location":"tutorials/tutorial_12/tutorial/#tutorial-12-quantum-embedding-with-time-dependent-embedded-mean-field-theory-hydrogenation-and-excitations-of-pentacene","title":"Tutorial 12: Quantum embedding with (time-dependent) embedded mean-field theory: hydrogenation and excitations of pentacene","text":"<p> Version: all versions  Joseph Prentice </p>"},{"location":"tutorials/tutorial_12/tutorial/#introduction","title":"Introduction","text":""},{"location":"tutorials/tutorial_12/tutorial/#the-utility-of-quantum-embedding","title":"The utility of quantum embedding","text":"<p>Although ONETEP <sup>1</sup> makes first principles calculations of systems containing thousands of atoms feasible, particularly when using semi-local exchange-correlation functionals, it can still be very computationally costly to treat entire systems of this size with higher level theory, such as hybrid functionals, which require the computation of exact exchange. This is particularly relevant for excited state calculations, due to the well-known underestimation of the band gap by semi-local DFT, making excitation spectra performed with semi-local DFT quantitatively, or sometimes qualitatively wrong. However, if the physics/chemistry of interest in the system is known or expected to be localised to a particular subregion -- we call this the <code>active region</code> -- with the rest of the system acting as an environment influencing the active region, quantum embedding provides a way to achieve hybrid accuracy with a significantly reduced cost.</p> <p>This is achieved by treating the active region alone with the higher level of theory, with the rest of the system (the environment) treated at a lower level of theory. In ONETEP at present, this translates to treating the active region with hybrid DFT, and the environment with semi-local DFT. This is done within a single self-consistent calculation, to ensure that the two regions are able to influence one another. As hybrid DFT is only performed on the active region, which is typically small compared to the environment, the computational cost is significantly reduced.</p>"},{"location":"tutorials/tutorial_12/tutorial/#embedded-mean-field-theory","title":"Embedded mean-field theory","text":"<p>There are many different quantum embedding schemes; the scheme used in ONETEP is embedded mean-field theory (EMFT), originally proposed by Fornace et al. <sup>4</sup> This scheme has several advantages, including two particularly relevant to ONETEP: firstly, it partitions the system at a basis-set level, which works well with ONETEP's atom-centred NGWF basis.  Secondly, it is a mean-field theory throughout, like DFT, which means that many existing methods based on DFT can be easily modified to accommodate EMFT. This includes linear-response time-dependent DFT (LR-TDDFT), which allows electronic excitations to be computed -- we refer to this as TD-EMFT. For more details, please see the original EMFT paper <sup>4</sup>, and the papers implementing ground state EMFT <sup>2</sup> and TD-EMFT <sup>3</sup> in ONETEP.</p> <p>EMFT is also fully compatible with the implicit solvent methods available within ONETEP, allowing for multi-level modelling of systems.</p>"},{"location":"tutorials/tutorial_12/tutorial/#pentacene","title":"Pentacene","text":"<p>In this tutorial, we will look at both ground state EMFT and TD-EMFT, with the pentacene molecule as our test case. Ground state EMFT is demonstrated by looking at the terminal hydrogenation energy of pentacene, following Prentice et al. <sup>2</sup>, and TD-EMFT is demonstrated by looking at the first excitation energy of pentacene-doped p-terphenyl, following Prentice. <sup>3</sup></p>"},{"location":"tutorials/tutorial_12/tutorial/#ground-state-emft-terminal-hydrogenation-of-pentacene","title":"Ground-state EMFT: terminal hydrogenation of pentacene","text":""},{"location":"tutorials/tutorial_12/tutorial/#non-emft-baseline-calculations","title":"Non-EMFT baseline calculations","text":"<p>The terminal hydrogenation reaction for pentacene involves two hydrogen atoms becoming bonded to the two carbon atoms at one end of the pentacene molecule.</p> <p>Before using EMFT, we must first obtain the terminal hydrogenation energy without EMFT, with everything treated with first the PBE, then the B3LYP functionals. The input files required are <code>Pentacene.dat</code>, <code>HydrogenatedPentacene.dat</code>, and <code>H2.dat</code>.</p> <p>If you look at these files, you will notice that we have several different labels for carbon atoms (C1, C2, etc.) and similar for hydrogen atoms -- these will be used later to vary the size of our active region, by selecting different atoms to be included within it.</p> <p>To begin, simply run the input files as they are to obtain the ground state energy for the three structures at the PBE level. The hydrogenation energy can then be obtained as:</p> \\[    \\Delta E_{\\textrm{hyd}} = E_{\\textrm{Hydrogenated Pentacene}} - ( E_{\\textrm{Pentacene}} + E_{\\textrm{H2}} ) . \\] <p>Make sure you save the <code>.tightbox_ngwfs</code> file from the <code>H2.dat</code> calculation for use later!</p> <p>Now repeat this for B3LYP. In all three <code>.dat</code> files, change <code>xc_functional</code> to be <code>B3LYP</code>, and add the following keywords/blocks to set up Hartree-Fock exchange (deleting any species labels in the <code>species_swri...</code> block that are not present in that particular structure):</p> <pre><code>   %block swri\n     for_hfx 3 12 V 12 12 WE2\n   %endblock swri\n\n   %block species_swri-for_hfx\n   C\n   C1\n   C2\n   C3\n   H\n   H1\n   H2\n   H3\n   %endblock species_swri-for_hfx\n\n   hfx_use_ri for_hfx\n   hfx_max_l 3\n   hfx_max_q 12\n</code></pre> <p>For more details on the meaning of these keywords, see the HFx documentation. The most important point for our purposes here is that we can control which atoms are included in the computation of HFx through the <code>species_swri...</code> block -- this will become important for our EMFT calculations.</p> <p>For reasons of stability, it is best to start the B3LYP H2 calculation from the PBE-optimised NGWFs: bring back the PBE-optimised <code>.tightbox_ngwfs</code> file, and add <code>read_tightbox_ngwfs : T</code> to <code>H2.dat</code>. Make sure you still keep a copy of the PBE-optimised <code>.tightbox_ngwfs</code> file safe, as we will need it later.</p> <p>Run these three calculations and compute the hydrogenation energy at the B3LYP level.</p>"},{"location":"tutorials/tutorial_12/tutorial/#emft-calculations","title":"EMFT calculations","text":""},{"location":"tutorials/tutorial_12/tutorial/#4-carbon-atoms","title":"4 carbon atoms","text":"<p>We can now start to use EMFT to see if we can get close to the B3LYP result without treating the entire molecule with B3LYP. Initially, our active region will just include the 4 C atoms closest to the site of the reaction, and the hydrogen atoms bonded to them. We will only need to do EMFT calculations for <code>Pentacene.dat</code> and <code>HydrogenatedPentacene.dat</code> -- the hydrogen molecule will always be in the active region, so should always be treated with B3LYP, although there is one subtlety which will be introduced shortly.</p> <p>To turn on EMFT, change <code>xc_functional</code> back to <code>PBE</code>, and add the following keywords to <code>Pentacene.dat</code> and <code>HydrogenatedPentacene.dat</code> (keep the other modifications you already made for HFx for the moment):</p> <pre><code>   use_emft             T\n   use_emft_follow      T\n   use_emft_lnv_only    T\n   block_orthogonalise  F\n   active_xc_functional B3LYP\n   parallel_scheme      HOUSE\n\n   %block species_ngwf_regions\n   C1 H1\n   C C2 C3 H H2 H3\n   %endblock species_ngwf_regions\n</code></pre> <p>A brief explanation of each keyword:</p> <ul> <li><code>use_emft</code>: this turns on EMFT, so that the active region and    environment are treated with different levels of theory.</li> <li><code>use_emft_follow</code>: this toggles whether a non-EMFT calculation at    the lower level of theory (in this case, PBE) is done first, and    then uses that as a starting point for the EMFT calculation. For    this to happen, the value should be <code>T</code>.</li> <li><code>use_emft_lnv_only</code>: this toggles whether EMFT is used to    optimise both the NGWFs and the density kernel (value is <code>F</code>), or    just the density kernel (value is <code>T</code>). Typically, EMFT is only    used to optimise the density kernel (<code>T</code>), as NGWF optimisation    is poorly behaved under EMFT -- NGWFs can unphysically optimise    towards the region described by the level of theory that predicts    the lowest energy, and the block orthogonalisation procedure    designed to counteract this (discussed shortly) makes the NGWF    optimisation stall. The NGWFs are optimised at the lower level of    theory, and then fixed -- the error this introduces is typically    &lt;1% of the difference between the high and low levels of    theory. For more details, see Prentice et al. <sup>2</sup></li> <li><code>block_orthogonalise</code>: this toggles whether a block    orthogonalisation procedure is applied to the NGWFs before using    EMFT. This transforms the NGWFs of the environment so that they are    orthogonal to the NGWFs of the active region, so the off-diagonal    blocks of the overlap matrix are 0. This prevents the emergence of    unphysical solutions that can occur in some systems. For this to    happen, the value should be <code>T</code>.</li> <li><code>active_xc_functional</code>: this selects the functional that will be    used in the active region, whilst <code>xc_functional</code> selects the    functional used in the environment.</li> <li><code>parallel_scheme</code>: this decides how MPI processes should be split    between the regions. <code>HOUSE</code> means that the processes are    distributed proportionally to the number of atoms within each    region; <code>SENATE</code> means that the processes are distributed equally    between all regions; and <code>NONE</code> means that each region will use    all the processes in turn. <code>HOUSE</code> is strongly preferred.</li> <li><code>block species_ngwf_regions</code>: this assigns species to regions,    with one region per line. The first line is the active region by    default.</li> </ul> <p>The first four keywords should be turned to <code>T</code> in the order they are listed in. The first three keywords should almost always be <code>T</code> for an EMFT calculation, with <code>block_orthogonalise</code> turned on if the calculation proves unstable without it. Here, we leave it off.</p> <p>We also need to modify the HFx set-up to match the fact we only want HFx in the active region. To do this, simply delete any species in the <code>species_swri...</code> block that are not in the active region. Remember that each species in the active region should be on its own line in the <code>species_swri...</code> block, whereas all the species in the active region should be on the first line of the <code>species_ngwf_regions</code> block.</p> <p>Once these additions/modifications have been made, run the calculations for pentacene and hydrogenated pentacene.</p> <p>Before we can compute the hydrogenation energy from these results, there is one more subtlety. As we optimised the active region NGWFs at the lower level of theory, but the active region density kernel with the higher level of theory, we need to do the same in our hydrogen molecule for consistency. To do this, bring back the <code>H2.tightbox_ngwfs</code> file you saved from the PBE calculation earlier, and re-run your B3LYP <code>H2.dat</code> calculation with the following modifications/additions:</p> <pre><code>   read_tightbox_ngwfs : T\n   maxit_ngwf_cg : 0\n</code></pre> <p>You can now use these three results to compute the hydrogenation energy with an active region of this size.</p>"},{"location":"tutorials/tutorial_12/tutorial/#larger-active-regions","title":"Larger active regions","text":"<p>Next, expand the active region to include the 8 carbon atoms closest to the reaction site. To do this, add the C2 and H2 species to the active region (remember to remove them from the environment region!), and modify the HFx set-up to match. Rerun the pentacene and hydrogenated pentacene calculations, and compute the hydrogenation energy (you don't need to rerun the hydrogen molecule calculation, as you can just reuse the result obtained using PBE-optimised NGWFs).</p> <p>Finally, expand the active region further to include the 12 carbon atoms closest to the reaction site, by adding C3 and H3 to the active region. Re-calculate the hydrogenation energy.</p> <p>If you plot the hydrogenation energy vs. the size of the active region, you should see the hydrogenation energy approach the full B3LYP result. This demonstrates the ability of EMFT to obtain high level results at a reduced cost, even when the boundary between regions cuts through covalent bonds.</p> <p>This also demonstrates the importance of selecting the appropriate active region. In systems made up of weakly bonded parts (e.g. molecular crystals, solvated systems), the appropriate active region will often be obvious -- it will be the molecule or molecules of interest (examples of multiple-molecule active regions could include a nearest-neighbour dimer or a solute along with some nearest-neighbour solvent atoms). In extended covalent or ionic systems, the choice of active region may be more difficult, and should be carefully converged, in a similar way to that shown in this tutorial.</p>"},{"location":"tutorials/tutorial_12/tutorial/#further-investigations","title":"Further investigations","text":"<p>To further investigate the use of EMFT in ONETEP, you could look at the effects of:</p> <ul> <li>changing the active region further -- perhaps including more C    atoms, excluding H atoms, etc.,</li> <li>using block orthogonalisation,</li> <li>using other functionals for either the high or low level of theory    -- semi-local functionals can be used for the higher level,    although this is of course not expected to produce a significant    advantage,</li> </ul> <p>and many other possibilities. </p>"},{"location":"tutorials/tutorial_12/tutorial/#td-emft-excitations-of-pentacene-doped-p-terphenyl","title":"TD-EMFT: excitations of pentacene-doped p-terphenyl","text":""},{"location":"tutorials/tutorial_12/tutorial/#non-emft-benchmark","title":"Non-EMFT benchmark","text":"<p>Here, we will be looking at the S0 to S1 transition in pentacene, which is the lowest excited state observed in TDDFT. This is significantly affected by the environment. In particular, we are interested in pentacene-doped p-terphenyl, which is of interest for room-temperature maser applications, and how the p-terphenyl environment affects the excitation energy.</p> <p>To give us a reference for isolated pentacene, we first need to perform a high-level TDDFT calculation for pentacene. We will again use B3LYP as our high-level theory. The input file is <code>Pentacene_isolated.dat</code> -- as this tutorial assumes you are already familiar with running TDDFT calculations with ONETEP, we will not go into any detail, and this calculation can just be run as it is.</p>"},{"location":"tutorials/tutorial_12/tutorial/#td-emft-calculation","title":"TD-EMFT calculation","text":"<p>We now perform a TD-EMFT calculation for a pentacene molecule surrounded by 6 p-terphenyl molecules, as extracted from the pentacene-doped p-terphenyl molecular crystal. The input file is <code>Pentacene_in_p-terphenyl.dat</code>. This can be run as it is, but one point regarding EMFT should be noted first. The general set-up of the EMFT calculation is precisely the same as for ground state EMFT, with one addition: the <code>species_tddft_kernel</code> block. By using this block, we can specify which species we will restrict our excitations to be localised on. Given that in a TD-EMFT calculation we expect the excitations of interest to be localised within the active region, the species contained within the <code>species_tddft_kernel</code> block should be a subset of those in the active region. Typically, the two will be identical, i.e., the contents of the <code>species_tddft_kernel</code> block should be the same as the first line of the <code>species_ngwf_regions</code> block. For more details, see the LR-TDDFT documentation.</p> <p>Run this calculation -- this may take some time. If you compare this to the results in Prentice <sup>3</sup>, you can see that the result is very close to the experimental value of 2.09 eV.</p> <p>You can plot the resulting excitation as a <code>.cube</code> file, and visualise it using e.g. VESTA.</p>"},{"location":"tutorials/tutorial_12/tutorial/#files-for-this-tutorial","title":"Files for this tutorial","text":"<ul> <li>Pentacene.dat</li> <li>HydrogenatedPentacene.dat</li> <li>H2.dat</li> <li>Pentacene_isolated.dat</li> <li>Pentacene_in_p-terphenyl.dat</li> <li>C_NCP19_PBE_OTF.usp</li> <li>H_NCP19_PBE_OTF.usp</li> </ul>"},{"location":"tutorials/tutorial_12/tutorial/#references","title":"References","text":"image/svg+xml <ol> <li> <p>J. C. A. Prentice, J. Aarons, J. C. Womack, A. E. A. Allen, L. Andrinopoulos, L. Anton, R. A. Bell, A. Bhandari, G. A. Bramley, R. J. Charlton, R. J. Clements, D. J. Cole, G. Constantinescu, F. Corsetti, S. M. M. Dubois, K. K. B. Duff, J. M. Escartin, A. Greco, Q. Hill, L. P. Lee, E. Linscott, D. D. O'Regan, M. J. S. Phipps, L. E. Ratcliff, A. Ruiz Serrano, E. W. Tait, G. Teobaldi, V. Vitale, N. Yeung, T. J. Zuehlsdorff, J. Dziedzic, P. D. Haynes, N. D. M. Hine, A. A. Mostofi, M. C. Payne, and C.-K. Skylaris, The ONETEP linear-scaling density functional theory program, J. Chem. Phys. 152, 174111 (2020).\u00a0\u21a9</p> </li> <li> <p>J. C. A. Prentice, R. J. Charlton, A. A. Mostofi, and P. D. Haynes, Combining Embedded Mean-Field Theory with Linear-Scaling Density-Functional Theory, J. Chem. Theory Comput. 16, 354 (2020).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>J. C. A. Prentice, Efficiently Computing Excitations of Complex Systems: Linear-Scaling Time-Dependent Embedded Mean-Field Theory in Implicit Solvent, J. Chem. Theory Comput. 18, 1542 (2020).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>M. E. Fornace, J. Lee, K. Miyamoto, F. R. Manby, and T. F. Miller, Embedded Mean-Field Theory, J. Chem. Theory Comput. 11, 568 (2015).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_13/tutorial/","title":"Tutorial 13","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 13"},{"location":"tutorials/tutorial_13/tutorial/#tutorial-13-ase-onetep-interface","title":"Tutorial 13: ASE ONETEP interface","text":"<p> Version: all versions  Tom Demeyere </p>"},{"location":"tutorials/tutorial_13/tutorial/#preamble-download-links","title":"Preamble &amp; Download links","text":"<p>Here is the tutorial for the ONETEP interface in ASE.  It is a work in progress, but if you wish to give it a try, please find the two files:</p> <ul> <li>learn_ase_in_y_minutes.py</li> <li>onetep_interface.py</li> </ul> <p>The first file is a general tutorial for people who are not used to ASE. The second file is a small file that explains how to use the ONETEP interface with ASE.</p> <p>Below is the documentation for the ONETEP interface in ASE, as plan to be included in the ASE documentation.</p>"},{"location":"tutorials/tutorial_13/tutorial/#introduction","title":"Introduction","text":"<p>ONETEP is a linear-scaling density functional theory code which exploit the near-sightness of the electronic density. It uses a set of atom-centered local  orbitals (denoted NGWFs) which are optimised in situ to enable calculations  with a minimal number of orbitals.</p> <p>This interface makes it possible to use ONETEP as a calculator in ASE. You need to have a copy of the ONETEP code (and an appropriate license) to use this interface.</p>"},{"location":"tutorials/tutorial_13/tutorial/#environment-variables","title":"Environment variables","text":"<p>The environment variable <code>ASE_ONETEP_COMMAND</code> must hold the command to invoke the ONETEP calculation. The variable must be a string with a link to the ONETEP binary, and any other specific settings required for your environment (srun, mpirun, ...)</p> <p>You can setup this environment variable in your shell configuration file:</p> <pre><code>  $ export ASE_ONETEP_COMMAND=\"export OMP_NUM_THREADS=4; mpirun -n 6 ~/onetep/bin/onetep.arch\"\n</code></pre> <p>Or within python itself:</p> <pre><code>  &gt;&gt;&gt; environ[\"ASE_ONETEP_COMMAND\"]=\"export OMP_NUM_THREADS=4; mpirun -n 6 ~/onetep/bin/onetep.arch\"\n</code></pre> <p>ASE will automatically redirect stdout and stderr to the appropriate files, namely \"\\(LABEL.out\" and \"\\)LABEL.err\" where label is the name used for your ONETEP calculations</p>"},{"location":"tutorials/tutorial_13/tutorial/#pseudopotentials","title":"Pseudopotentials","text":"<p>ONETEP accepts PAW datasets in the abinit format, and NCP pseudpotentials with formats  USP and recpot. Support has recently been added for the upf format, for both PAW and NCPP potentials. Pseudopotentials are passed directly to the Onetep calculator as a dictionary definition. If no pseudopotentials are passed ASE will try to guess the files based on the element used and the pseudo_path variable. </p> <pre><code>    # Explicitly providing each path\n    calc = Onetep(pseudopotentials = {'H': '/path/to/pseudos/H.usp', 'O': '/path/to/pseudos/O.usp'})\n    # Using pseudo_path\n    calc = Onetep(pseudo_path = '/path/to/pseudos', pseudopotentials = {'H': 'H.usp', 'O': 'O.usp'})\n    # ASE will try to guess them\n    calc = Onetep(pseudo_path = '/path/to/pseudos')\n</code></pre> <p>For ASE to correctly guess the pseudopotentials, it is best to use a pseudo_path that contains only one pseudopotential file for each element.</p>"},{"location":"tutorials/tutorial_13/tutorial/#onetep-calculator","title":"ONETEP Calculator","text":"<p>Simple calculations can be setup calling the Onetep calculator without any parameters, in this case ONETEP's default parameters will be used. For more complex cases using the keywords parameters is necessary. The 'keywords' parameters is a dictionary, in which each of the keys is a string that should be a ONETEP keyword, and the corresponding value is what you want to set that keyword to in the input.</p>"},{"location":"tutorials/tutorial_13/tutorial/#examples","title":"Examples","text":"<p>Here is an example python script which sets up a calculation on a water molecule: </p> <pre><code>    from ase.build import molecule\n    from ase.calculators.onetep import Onetep\n    from os import environ\n\n    # water molecule from ASE database, centered in a ~ 24 \u00c5 box\n    wat = molecule('H2O')\n    wat.center(12)\n    environ[\"ASE_ONETEP_COMMAND\"]=\"export OMP_NUM_THREADS=8; mpirun -n 2 ~/onetep/bin/onetep.arch\"\n    # Ouput will be in \"water.out\"\n    calc = Onetep(label = 'water', xc = 'PBE', paw = True, pseudo_path = '/path/to/pseudos')\n    wat.calc = calc\n    wat.get_potential_energy()\n</code></pre> <p>Here is a more complex example, this time setting up a Pt13 cluster and running a geometry optimisation on 64 cores: </p> <pre><code>    from os import environ\n\n    import numpy as np\n\n    from ase.build import molecule\n    from ase.calculators.onetep import Onetep\n    from ase.cluster import Octahedron\n    from ase.optimize.sciopt import SciPyFminBFGS\n    # Pt13 from ase.cluster\n    nano = Octahedron('Pt', 3, 1)\n    nano.set_cell(np.eye(3)*12)\n    nano.center()\n\n    label = 'pt13'\n\n    environ[\"ASE_ONETEP_COMMAND\"]=\"export OMP_NUM_THREADS=8; mpirun -n 8 ~/onetep/bin/onetep.arch\"\n\n    # ONETEP default are atomic units, one can specify 'cutoff_energy' : '600 eV' if needed.\n    keywords = {\n        'xc' : 'rpbe',\n        'do_properties' : True,\n        'cutoff_energy' : 35,\n        'output_detail': 'verbose',\n        'elec_energy_tol': 1.0e-5/len(atoms),\n    }\n\n    # Ouput will be in \"pt13.out\", \n    # append = True will not overwrite file at each step\n    calc = Onetep(\n        label = label,\n        edft = True,\n        append = True,\n        pseudo_path = '/path/to/pseudos', \n        keywords = keywords)\n\n    nanoparticle.calc = calc\n\n    opt = SciPyFminBFGS(atoms = nano, trajectory = label + \".traj\", logfile = label + \".log\")\n    opt.run(fmax=0.01)\n</code></pre> <p>Here is an example of setting up an EELS and LDOS calculation on an N-substituted graphene sheet, demonstrating several more advanced functionalities (eg tags, species groups, and overrides to pseudopotentials and atomic solver strings): </p> <pre><code>    import numpy as np\n\n    from ase.build import graphene_nanoribbon\n    from ase.calculators.onetep import Onetep\n    from ase.io import write\n    from numpy.linalg import norm\n    from numpy.random import choice\n\n    sheet = graphene_nanoribbon(10, 10, type='zigzag', vacuum = 10)\n\n    # Get all distances to center of mass\n    com = sheet.get_center_of_mass()\n    distances_to_com = norm(sheet.positions - com, axis = 1)\n\n    # Find atoms close to com and change one randomly to N\n    p, = np.where(distances_to_com &lt; 5)\n    to_nitro = choice(p)\n    sheet[to_nitro].symbol = 'N'\n\n    shell_rad = np.array([1.5, 2.5, 3.0, 4.0, 4.5])\n\n    tags = np.zeros(len(sheet), dtype=np.int32)\n\n    # We want to tag atoms that are close to the introduced nitrogen\n    for idx, rad in enumerate(reversed(shell_rad)):\n        # All distances N-C\n        dist = norm(sheet[to_nitro].position - sheet.get_positions(), axis = 1)\n        # Which ones are closest to rad?\n        p, = np.where(dist &lt; rad)\n        # Cannot be the nitrogen itself\n        p = p[p != to_nitro]\n        # Tags them\n        tags[p] = len(shell_rad) - idx\n\n    sheet.set_tags(tags)\n\n    tags = ['' if i == 0 else i for i in tags]\n\n    species = np.unique(np.char.add(sheet.get_chemical_symbols(), tags))\n\n    keywords = {\n        'species_core_wf' : ['N /path/to/pseudo/corehole.abinit'],\n        'species_solver' : ['N SOLVE conf=1s1 2p4'],\n        'pseudo_path': '/Users/tomdm/PseudoPotentials/SSSP_1.2.1',\n        'xc' : 'PBE',\n        'paw': True,\n        'do_properties': True,\n        'cutoff_energy' : '500 eV',\n        'species_ldos_groups': species,\n        'task' : 'GeometryOptimization'\n    }\n\n    calc = Onetep(\n        label = 'N_doped_graphene_001',\n        keywords = keywords\n    )\n\n    # Checking the input before running the calculation\n    write('to_check.dat', sheet, format='onetep-in', keywords = keywords)\n\n    sheet.calc = calc\n    # Will actually run the geometry optimisation\n    # using ONETEP internal BFGS\n    sheet.get_potential_energy()\n</code></pre> <p>Quickly restart with solvation effect using the soft sphere model </p> <pre><code>    from ase.io import read\n    from ase.io.onetep import get_onetep_keywords\n\n    # Read from the previous run...\n    optimized_sheet = read(\"N_doped_graphene_001.out\")\n\n    # Function to retrieve keywords dict from input file...\n    keywords = get_onetep_keywords('N_doped_graphene_001.dat')\n\n    # We add solvation keywords\n    keywords.update(\n        {\n        'is_implicit_solvent': True,\n        'is_include_apolar': True,\n        'is_smeared_ion_rep': True,\n        'is_dielectric_model': 'fix_cavity',\n        'is_dielectric_function' : 'soft_sphere'\n        }\n    )\n\n    optimized_sheet.calc = Onetep(...)\n\n    ...\n</code></pre> image/svg+xml"},{"location":"tutorials/tutorial_14/tutorial/","title":"Tutorial 14","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 14"},{"location":"tutorials/tutorial_14/tutorial/#tutorial-14-electron-energy-loss-spectroscopy-in-onetep","title":"Tutorial 14: Electron Energy Loss Spectroscopy in ONETEP","text":"<p> Version: all versions  Edward Tait; Nicholas Hine </p>"},{"location":"tutorials/tutorial_14/tutorial/#introduction","title":"Introduction","text":"<p>EELS (Electron Energy Loss Spectroscopy) is a spectroscopic technique which  combines high spatial resolution with fair energy resolution, and is thus sensitive to local electronic structure in a material. The theory behind EELS calculations in ONETEP is explained in the  documentation page on EELS, as well as in a paper giving an overview of the capabilities [1^], and in the thesis of one of the authors (Edward Tait) <sup>2</sup>. </p> <p>EELS calculations in ONETEP proceed by running first a singlepoint calculation (with or without a core hole, as required) and then running a properties calculation. The properties calculation will output files suitable for use with the OptaDoS package, after a little renaming and rearrangement which can be carried out with a script provided. </p>"},{"location":"tutorials/tutorial_14/tutorial/#system-setup","title":"System setup","text":"<p>We will demonstrate the procedure for running an EELS calculation on a toy system: silene (the silicon equivalent of ethene). An example input file is provided in the Files section below, as are the PAW potentials for Silicon and Hydrogen and the associated core wavefunction data for Silicon.  The tutorial files use the JTH pseudopotentials [^5], with the addition of core orbitals, and we also regenerated the PAW potential and Core orbitals with a core hole, for the later part of this tutorial.</p> <p>There are a few differences between the ONETEP input here and one for a typical single point calculation:</p> <ul> <li>PAW is mandatory</li> <li>We specify a second species for the atom whose core electrons we are exciting</li> <li>Because a conduction calculation is being performed we must provide a <code>species_cond</code> block</li> <li>We must provide a <code>species_core_wf</code> block and every species must be listed there.</li> </ul> <p>The input file can be run swiftly on a single node and should produce a large number of output files. Most of these files are <code>.cube</code> files of wavefunctions produced by default during the properties calculations. The files of interest are the <code>.elnes_bin</code> files, which contain OptaDoS compatible matrix elements.</p> <p>A little more setup is needed before we can run OptaDoS (using the silene example):</p> <ul> <li>A dummy castep <code>silene-out.cell</code> file must be produced, and it must contain a symmetry block</li> <li>By default two <code>.elnes bin</code> files are produced, one based on Kohn-Sham wavefunctions represented using only the valence NGWFs (<code>silene_val_grad.elnes_bin</code>) and a second which makes use of the joint basis of valence and conduction NGWFs (<code>silene_joint_grad.elnes_bin</code>)</li> <li>As per the discussion above, you should choose the latter and copy it to <code>silene.elnes bin</code>.</li> <li>A <code>silene.bands</code> file must be produced, this is best done by copying <code>silene.joint bands</code> to <code>silene.bands</code>.</li> <li>An OptaDoS input file, <code>silene.odi</code> is needed.</li> </ul> <p>To assist in these tasks a utility script, <code>prep_optados_eels</code>, is provided in the utils folder of the onetep distribution. Run it with the calculation seed name as its argument and the steps listed above will be completed automatically.</p> <p>The .odi file produced should be regarded as a basic template, consult the OptaDoS documentation [^6] if you wish to use more advanced features. Note that at the moment only fixed broadening is supported by onetep. When you are satisfied with your OptaDoS input file, execute OptaDoS with your calculation seed name as the argument. All being well, you should see a .dat file which you can plot with your favorite tool. Individual edges are listed sequentially in the file, so a little post processing with awk or python is needed to separate the edges for individual plotting</p>"},{"location":"tutorials/tutorial_14/tutorial/#files-for-this-tutorial","title":"Files for this tutorial","text":"<ul> <li>Si2H4_EELS_Example.dat</li> <li>H.PBE-paw.abinit</li> <li>Si.PBE-paw.abinit</li> <li>Si.PBE-paw.corewf.abinit</li> <li>Si_corehole.PBE-paw.abinit</li> <li>Si_corehole.PBE-paw.corewf.abinit</li> </ul> image/svg+xml <ol> <li> <p>N. D. M. Hine, Linear-Scaling Density Functional Theory using the Projector   Augmented Wave Method, J. Phys. Condens. Matter 29, 024001 (2017).   https://iopscience.iop.org/article/10.1088/0953-8984/29/2/024001\u00a0\u21a9</p> </li> <li> <p>Linear-Scaling Density Functional Theory and Theoretical Electron Energy   Loss Spectroscopy Investigations of Surfaces and Defects in Nanomaterials,   PhD Thesis of Edward Tait, 2019, University of Cambridge   https://www.repository.cam.ac.uk/items/fcc71788-1468-47f7-989c-9a9d6e349f1e\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_4/tutorial/","title":"Tutorial 4","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 4"},{"location":"tutorials/tutorial_4/tutorial/#tutorial-4-geometry-optimization","title":"Tutorial 4: Geometry optimization","text":"<p> Version: all versions  Simon M.-M. Dubois;   </p>"},{"location":"tutorials/tutorial_4/tutorial/#introduction","title":"Introduction","text":"<p>This tutorial aims at showing how to run a simple geometry optimization with ONETEP.</p> <p>Geometry optimization is one of the primary tasks in quantum simulation. The essence of the calculation is for the constituting atoms to be moved to the positions where the total energy is minimal. In general, this can be tackled efficiently if the forces on the atoms can be computed. Over the past twenty years, various schemes have been derived to solve this problem in the framework of ab initio calculations. These range from simple approaches based on molecular dynamics, such as the steepest descent and damped dynamics methods, to the more sophisticated conjugated gradient and Quasi-Newton methods.</p> <p>The geometry optimization scheme implemented in ONETEP relies on the isolation of the atomic and electronic subsystems (i.e. the Born-Oppenheimer approximation). For a given configuration of the ionic positions, the electronic degrees of freedom are completely relaxed so that the electronic subsystem stays on the Born-Oppenheimer surface. All the possible configurations of the ionic positions therefore define a multi-dimensional potential energy surface for which we want to find the global minimum. The atomic forces are calculated by application of the Hellmann-Feynman theorem and the ionic positions are moved around by means of the Broyden-Fletcher-Goldfarb-Shanno (BFGS) method in order to find the minimum of the potential energy. At this point, one has to keep in mind that several local minima may be present in the configuration space and the algorithm can get trapped in one of those. Therefore, despite the sophistication of the minimization method, the location of a global minimum still requires the intuition of a good starting point.</p> <p>The calculation flow of a geometry optimization in ONETEP is a three step process:</p> <ol> <li> <p>Given an ionic configuration, the electronic degrees of freedom are relaxed   (cfr. self-consistent optimization of the density kernel and NGWFs).</p> </li> <li> <p>The total energy and atomic forces are computed and compared with those of   previous ionic configurations. The threshold chosen as stopping criterion for   the geometry optimization is tested.</p> </li> <li> <p>The atomic position are updated by means of the BFGS algorithm.</p> </li> </ol>"},{"location":"tutorials/tutorial_4/tutorial/#the-ethene-molecule","title":"The Ethene Molecule","text":"<p>As a first example, we will deal with the geometry optimization run a geometry optimization of the ethene molecule. The following is a rough guide through the  input file.</p> <p>First, we need to set</p> <pre><code>    task : GeometryOptimization\n</code></pre> <p>For the SCF part, try running a calculation with an energy cutoff of about 650 eV, NGWF radii of about 6.0 Bohr and a cubic simulation cell of side-length 40 Bohr:</p> <pre><code>    cutoff_energy          : 650.0 eV\n    output_detail : VERBOSE\n\n    %block species\n    H  H  1  1  6.75\n    C  C  6  4  6.75\n    %endblock species\n\n    %block lattice_cart\n    Ang\n    20.0 0.0 0.0\n    0.0 20.0 0.0\n    0.0 0.0 20.0\n    %endblock lattice_cart\n\n    %block positions_abs\n    Ang\n    C  5.0000000000000000  5.9228319999999997  6.9051750000000007\n    C  5.0000000000000000  5.9228319999999997  5.5702150000000001\n    H  5.0000000000000000  6.8456639999999993  7.4753900000000009\n    H  5.0000000000000000  5.0000000000000000  7.4753900000000009\n    H  5.0000000000000000  6.8456639999999993  5.0000000000000000\n    H  5.0000000000000000  5.0000000000000000  5.0000000000000000\n    %endblock positions_abs\n</code></pre> <p>You will also need the pseudopotential block:</p> <pre><code>    %block species_pot\n    H   hydrogen.recpot\n    C   carbon.recpot\n    %endblock species_pot\n</code></pre> <p>A full example input/output file can be downloaded here</p> <p>Now you are ready to run ONTEP: <pre><code>    mpirun -n 2 onetep ethene.dat | tee ethene.out\n</code></pre></p> <p>The calculation should take ~15 min on 2 MPI processes (on a  Intel Xeon Silver 4114 cpu). In the meantime you may want to repeat the procedure with varying parameters in order to converge the calculation with respect to the cutoff energy, the NGWF radii, as well as the size of the simulation cell. Besides, if you aim to compute a properties (e.g. the C-C bond length) with a given computational accuracy (e.g. 0.005 Ang), you should also check that the <code>geom_max_iter</code> and <code>ngwf_treshold_orig</code>  parameters do not prevent to reach the desired accuracy.</p> <p>The output of ONETEP consists principally of two files: <code>ethene.out</code> (the main output file) and <code>ethene.geom</code>. This latter contains one block of information for each iteration of the geometry optimization. Each block looks like: <pre><code>                               4\n                -1.37265351E+001     -1.37265351E+001                       &lt;-- E\n                 3.77945227E+001      0.00000000E+000      0.00000000E+000  &lt;-- h\n                 0.00000000E+000      3.77945227E+001      0.00000000E+000  &lt;-- h\n                 0.00000000E+000      0.00000000E+000      3.77945227E+001  &lt;-- h\n    C     1      9.44793440E+000      1.11928879E+001      1.30335653E+001  &lt;-- R\n    C     1      9.44790699E+000      1.11928871E+001      1.05404458E+001  &lt;-- R\n    H     1      9.44899454E+000      1.29429511E+001      1.41255628E+001  &lt;-- R\n    H     1      9.44900396E+000      9.44173342E+000      1.41253623E+001  &lt;-- R\n    H     1      9.44897328E+000      1.29435030E+001      9.45003514E+000  &lt;-- R\n    H     1      9.44897086E+000      9.44121996E+000      9.45024026E+000  &lt;-- R\n    C     1     -1.75749466E-005     -2.60718796E-004     -3.74725290E-004  &lt;-- F\n    C     1     -1.20705498E-005     -2.14434259E-004      2.65511453E-004  &lt;-- F\n    H     1      1.13344672E-005      2.37875189E-004      1.82501034E-005  &lt;-- F\n    H     1      9.56687732E-006      1.39393204E-005     -1.03600237E-004  &lt;-- F\n    H     1      4.64762662E-006      1.58612511E-004      4.33446848E-005  &lt;-- F\n    H     1      4.09652530E-006      6.47260346E-005      1.51219285E-004  &lt;-- F\n</code></pre> where all values are in Hartree atomic units and</p> <ul> <li>The first line is the iteration number.</li> <li>The second line is the total energy.</li> <li>The next three lines are the lattice vectors expressed in Caresian coordinates.</li> <li>The next N lines (where N is the number of atoms) give the atomic coordinates.</li> <li>The following N lines give the atomic forces.</li> </ul> <p>The main informations regarding the geometry optimization are gathered in the <code>ethene.geom</code> file, however you may want to visualize the results in a glimpse. You can use the perl script geom2xyz.x to generate a <code>.xyz</code> file containing the atomic coordinates at each iteration of the geometry optimization:</p> <pre><code>    chmod 700 geom2xyz.x\n    geom2xyz.x ethene.geom\n</code></pre> <p>This should produce a file <code>ethene.xyz</code> that you can visualize with your favourite package (e.g. XCrysDEN).  Though the film of the relaxation provides you with crucial information such as the appearance of dissociation, symmetry breaking, etc.  It is a good practice to keep track of the energy and forces at each iteration  in order to assess the relaxation process. The <code>-- E</code> tag which labels the  total energies in the <code>ethene.geom</code> file may be used for that purpose.  Create a new file <code>ethene_energy.dat</code> and plot the evolution of the  total energy using:</p> <pre><code>    $ grep ' E' ethene.geom | awk '{print $1}' &gt; ethene_energy.dat\n    $ gnuplot plot with lines 'ethene_energy.dat'\n</code></pre> <p>You should notice that the total energy of the system decreases monotonically. Similarly, you can keep track of the maximum rms force on the ions at each iteration by running:</p> <pre><code>    $ grep \"&lt;-- BFGS\" ethene.out | grep \"|F|max\"\n</code></pre> <p>This should produce you something like:</p> <pre><code>    |  |F|max   |   2.038842E-002 |   2.000000E-003 |    Eh/Bohr | No  | &lt;-- BFGS\n    |  |F|max   |   3.567221E-003 |   2.000000E-003 |    Eh/Bohr | No  | &lt;-- BFGS\n    |  |F|max   |   5.188186E-003 |   2.000000E-003 |    Eh/Bohr | No  | &lt;-- BFGS\n    |  |F|max   |   1.375629E-003 |   2.000000E-003 |    Eh/Bohr | Yes | &lt;-- BFGS\n    |  |F|max   |   4.568394E-004 |   2.000000E-003 |    Eh/Bohr | Yes | &lt;-- BFGS\n</code></pre> <p>The second column is the calculated value of the maximum rms force on the atoms, the third column is the force threshold that the code is trying to achieve, the fourth column provides the units, and the fifth column informs you as to whether convergence of the force has been achieved or not. You may visualize this information using gnuplot:</p> <pre><code>    $ grep \"&lt;-- BFGS\" ethene.out | grep \"|F|max\" | awk '{print $4}' &gt; ethene_force.dat\n    $ gnuplot plot with lines 'ethene_force.dat'\n</code></pre> <p>You are now familiar with the geometry optimization scheme in ONETEP. You might examine in more details the input variables that allow to control the process. The keywords associated with the geometry optimization all start with the <code>geom_</code> prefix. Their description is found on the ONETEP Documentation.  In particular, take a few minutes to have a look at the variables: </p> <pre><code>    geom_max_iter\n    geom_convergence_win\n    geom_disp_tol\n    geom_energy_tol\n    geom_force_tol\n</code></pre> <p>Though their default values may appear to be convenient in most circumstances, these latter are the very basic input variables to master before launching a geometry optimization. Here, it is important to note that the three tolerance criteria (<code>geom_disp_tol</code>, <code>geom_energy_tol</code>, and <code>geom_force_tol</code>) are not exclusive. The three criteria have to be satisfied in order for the optimization to stop. You might have noticed that during the relaxation of ethene molecule, the default threshold imposed on the atomic forces (<code>geom_force_tol : 0.02 Ha/Bohr</code>) has been reached before the one associated with the convergence of the energy (<code>geom_energy_tol : 10e-06 Ha/Atom</code>).</p> <p>Like all the quasi-Newton schemes, the BFGS algorithm accumulates information about the Hessian matrix. As the the number of iteration increases, BFGS improves its knowledge of the the potential energy surface around the minimum and the matrix used to build the quadratic model of the potential energy surface converges towards the true Hessian matrix corresponding to the local minimum. However, the Hessian matrix is poorly approximated during the first few relaxation steps. It is therefore important to properly initialize the BFGS scheme. This may be conveniently done by means of a unique parameter <code>geom_frequency_est</code>. For the best efficiency, its value should corresponds to a rough estimation of the average of the optical phonon frequencies at the center of the Brillouin zone.</p> <p>In the case of the ethene molecule, the average of the experimentally reported vibration frequencies is 0.0081 Hartree. This value is very close to the default setting of <code>geom_frequency_est</code> and we do not expect any speed-up of the relaxation process by adjusting it.</p> <p>In various circumstances, it may appears convenient to impose some constraints to the atomic positions during the geometry optimization. Note that in the case of molecular systems it is often a good idea to keep an atom or an axis fixed during the optimization process in order to avoid losing computational time due to the rotations and/or translations of the system. Therefore it is worth having a quick look at the meaning of the variables:</p> <pre><code>    species\n    species_constraints\n</code></pre> <p>Finally, it is worth noting that, when running a geometry optimization, ONETEP produces a <code>.continuation</code> file. This latter contains all the information regarding the optimization process and can be very helpful to restart an optimization from a previous run. In such a case, the only thing you will need is to turn on the flag <code>geom_continuation</code>. In the same line of thought, a appropriate use of the keywords that control the reading/writting actions of the code, may help you to save some precious computational time:</p> <pre><code>    write_converged_dkngwfs\n    read_denskern\n    read_tightbox_ngwfs\n</code></pre> <p>For example, to use <code>write_converged_dkngwfs : T</code> is a good practice when running a molecular optimization as it avoid you to lose time in writing the density kernels and NGWFs on the disk.</p>"},{"location":"tutorials/tutorial_4/tutorial/#the-sucrose-molecule","title":"The Sucrose Molecule","text":"<p>At this point, you should be familiar with most of the keywords needed to run a proper geometry optimization. Therefore, we suggest you to leave the ethene molecule and to try to optimize a larger organic molecule. You can find an example input file for the sucrose molecule here. You should edit and read it carefully. You see that the <code>write_converged_dkngwfs</code> flag has been activated. In addition, the values of <code>ngwf_cg_max_step</code> and <code>lnv_cg_max_step</code> have been increased in order to allow unconstrained line search during the conjugate gradient optimization of the density kernel and NGWFs respectively.</p> <p>The calculation should take a bit more than an hour (with 16 MPI processes on a Intel Xeon Silver 4114 CPU). Keeping trace of the atomic forces, you should notice a rapid decrease of the maximum rms force on the ions during the first relaxation steps. However, the hydrogen atoms tend to wiggle quite a lot and it takes a some time for the positions to settle down according to relaxation criteria.</p> <pre><code>    | |F|max | 1.212754E-002 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 1.407689E-002 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 1.253042E-002 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 4.859480E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 1.052111E-002 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 5.953036E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 6.344620E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 6.587572E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 5.241521E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 5.455889E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n    | |F|max | 3.623343E-003 | 2.000000E-003 | Ha/Bohr | No | &lt;-- BFGS\n</code></pre> <p> </p> Fig.1: Ball stick representation of the sucrose molecule."},{"location":"tutorials/tutorial_4/tutorial/#periodic-crystals","title":"Periodic Crystals","text":"<p>Here above, the geometry optimization scheme has been illustrated by means of two molecular systems. Obviously, the same scheme holds for periodic crystals. As an example, we will investigate the adsorption of ammonia on a (10,8) carbon nanotube.</p> <p>The carbon nanotube considered here contains 488 carbon atoms in its unit-cell and its chiral periodicity is of 62.87 Bohr.</p> <p> </p> Fig.2: Ball-stick representation of the ammonia adsorbed on a CNT (10,8). <p>Following the prescriptions stated above, you should be able to write an input file for the nanotube (an example is given in here.). Note that for large systems, the spatial expansion of the density kernel has to be truncated in order to achieve the linear scaling. This can be done with the <code>kernel_cutoff</code> variable. Obviously, stringent truncation of the density kernel is expected to affect the accuracy of the calculation. Therefore, the cutoff length has to be carefully adjusted. You should already notice a significant decrease of the forces after the first few iterations.</p> image/svg+xml"},{"location":"tutorials/tutorial_5/tutorial/","title":"Tutorial 5","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 5"},{"location":"tutorials/tutorial_5/tutorial/#tutorial-5-analysis-and-visualization","title":"Tutorial 5: Analysis and visualization","text":"<p> Version: all versions  Jacek Dziedzic; Chris-Kriton Skylaris</p>"},{"location":"tutorials/tutorial_5/tutorial/#introduction","title":"Introduction","text":"<p>This tutorial demonstrates how to:</p> <ul> <li>Use ONETEP to calculate various electronic properties,</li> <li>Instruct ONETEP to generate files needed for later visualization of orbitals, electronic densities and potentials,</li> <li>Visualize these properties using VMD <sup>1</sup>,</li> <li>Set up and run a calculation on a nanostructure using a cut-off for the density kernel.</li> </ul>"},{"location":"tutorials/tutorial_5/tutorial/#density-spin-density-kohn-sham-orbitals-and-the-electrostatic-potential-for-ch3","title":"Density, spin density, Kohn-Sham orbitals and the electrostatic potential for CH<sub>3</sub>","text":"<p>In this part we will perform a calculation on the CH\\(_3\\) radical:</p> <p> </p> Fig.1: The CH3 radical. Visualization in VM. <p>As this molecule contains an odd number of electrons we need to perform a spin-polarised (unrestricted) calculation. In ONETEP this is achieved by optimising a different density kernel \\(K\\) for the \"up\"(\\(\\uparrow\\)) and the \"down\"(\\(\\downarrow\\)) spin:</p> \\[ \\rho\\left(\\mathbf{r}, \\mathbf{r}^{\\prime}\\right)=\\sum_{\\alpha \\beta} \\phi_\\alpha(\\mathbf{r}) K^{\\alpha \\beta(\\uparrow)} \\phi_\\beta^*\\left(\\mathbf{r}^{\\prime}\\right)+\\sum_{\\alpha \\beta} \\phi_\\alpha(\\mathbf{r}) K^{\\alpha \\beta(\\downarrow)} \\phi_\\beta^*\\left(\\mathbf{r}^{\\prime}\\right) \\]"},{"location":"tutorials/tutorial_5/tutorial/#prepreation","title":"Prepreation","text":"<p>The ONETEP input for this calcualtion are:</p> <ul> <li>Tnput: methyl.dat</li> <li>Geometry (in angstroem): methyl.pdb</li> </ul> <p>Note that the input file contains the coordinates as well (in atomic units), but not in a form directly readable by visualization packages. The <code>.pdb</code> file can be directly visualized in VMD.</p> <p>The input file specifies a single point energy calculation (<code>TASK SINGLEPOINT</code>) with a psinc kinetic energy cutoff of 800 eV (<code>CUTOFF_ENERGY 800.0 eV</code>), the Perdew-Zunger variant of the LSDA exchange-correlation functional (<code>XC_FUNCTIONAL CAPZ</code>) and the spin-polarised option (<code>SPINPOLARIZED TRUE</code>). Also notice the input flag <code>DO_PROPERTIES TRUE</code>, which proceeds with the calculation of various electronic properties at the end of the single point energy calculation.</p> <p>Run the input, redirecting the output to a file such as <code>methyl.out</code> (we also provide a reference methyl.out file).  The calculation should take a minute or two to run. </p>"},{"location":"tutorials/tutorial_5/tutorial/#visualisation-ionic-positions","title":"Visualisation [ionic positions]","text":"<p>Once it completes, you will notice that a number of <code>.cube</code> files have been created, including the file methyl_spindensity.cube. Let us examine this first. ONETEP can output volumetric data such as spin densities, charge densities, potentials, etc. There are three formats to choose from:</p> <ul> <li>Gaussian <code>.cube</code> format (<code>CUBE_FORMAT TRUE</code>)</li> <li>Materials Studio <code>.grd</code> format (<code>GRD_FORMAT TRUE</code>)</li> <li>OpenDX <code>.dx</code> format (<code>DX_FORMAT TRUE</code>). </li> </ul> <p>The <code>.cube</code> format has the advantage of having the ionic positions output in addition to the volumetric data.  In this tutorial we will use the <code>.cube</code> format which can be viewed with a number of free molecular visualisation programs. The instructions that follow are assuming that the VMD program can be used to visualize the files but in priciple you can use any other software that can display <code>.cube</code> files (such as VESTA, Molekel, gOpenMol, XCrySDens, etc).</p> <p>Start VMD by typing <code>vmd</code> in the terminal, use <code>File/New molecule/Browse</code> to find <code>methyl_spindensity.cube</code>, then click on <code>Load</code> to load the molecule. You should be able to see a crude, line-based representation of the molecule in a separate window. You can now get rid of the <code>Molecule file browser</code> window. Choosing <code>Graphics/Representations...</code> opens another window which lets you control the look of your molecule. In this window, change the <code>Drawing Method</code> from <code>Lines</code> to <code>CPK</code>, which will render your molecule in a ball-and-stick fashion, with the customary colouring <sup>2</sup>. Increase both <code>Sphere Resolution</code> and <code>Bond Resolution</code> (30 is a good value) to get rid of the jagged edges. You may wish to adjust <code>Sphere Scale</code> and <code>Bond Radius</code> to your liking as well.</p> <p>Try dragging with your mouse over the window that shows the molecule to rotate it. Try scrolling the mouse wheel to get closer or further away from the molecule. You may press the <code>=</code> key at any time to reset the view. Pressing the <code>T</code> key will get you to <code>Translate Mode</code>, where dragging with the mouse translates the molecule, instead of rotating it. To go back to <code>Rotate Mode</code>, press <code>R</code>. If your mouse lacks the scroll wheel, pressing <code>S</code> to go to <code>Scale Mode</code> might be of use. You should be able to obtain a representation similar to the one shown here.</p> <p> </p> Fig.2: The CH3 radical visualized in VMD with a ball-and-stick representation."},{"location":"tutorials/tutorial_5/tutorial/#visualisation-spin-density","title":"Visualisation [spin density]","text":"<p>So far we've only looked at the nuclei in the system. Let's try some electronic properties, starting from the spin density which we have already loaded, but not visualized yet. A neat thing about VMD is that you can use several representations at once. Thus, we can overlay the spin density isosurfaces on top of the CPK representation of the ions. In the <code>Graphics/Representations...</code> window click on <code>Create Rep</code>. This will clone the CPK representation, leaving you with two identical representations. Now change one of them to <code>Isosurface</code>. Not much will appear initially, because the default way of showing the isosurface is by using points. This is computationally cheap, but visually so as well. You can change this under <code>Draw</code>, by choosing <code>Solid Surface</code>. Before you do it, however, make sure to move the <code>Isovalue</code> slider to something different than the default 0.0 (or type a value in the box). This is because there is a huge number of points in our system (some 400000) where the spin density is exactly or almost exactly zero (everywhere outside our molecule). Trying to draw a surface through these points usually confuses VMD to the point of crashing or at least stuttering. For this reason it is best to pick any value other than the default of 0.0 to start from, before choosing <code>Solid Surface</code>.</p> <p>Experiment with the settings (<code>Coloring Method</code>, <code>Material</code>, <code>Isovalue</code>) to get a feel for how they work. It makes sense to set <code>Coloring Method</code> to <code>ColorID</code> here, as this lets us to manually pick a colour for the isosurface (from the drop-down box near <code>ColorID</code>). After some adjustments you should obtain an isosurface similar to the one shown here. Do not worry if you cannot get the transparency right - it's only possible when you render \"production quality\" images, think of what you see as a draft.</p> <p> </p> Fig.3: The spin density of the CH3 radical visualized in VMD. <p>What we have obtained is the textbook picture of the spin density of a methyl radical. It has positive as well as negative regions which is a consequence of the fact that the spatial parts of the Kohn-Sham orbitals for each spin are allowed to be different, even for doubly occupied states.</p>"},{"location":"tutorials/tutorial_5/tutorial/#visualisation-kohn-sham-orbtials","title":"Visualisation [Kohn-Sham orbtials]","text":"<p>The properties calculation also produces Kohn-Sham orbitals. Their energies for each spin are printed in the output file (try to find them, they are towards the very end, copy them into the table below) and <code>.cube</code> files for the squares of some of the orbitals are also produced. HOMO orbitals are written, separately for each spin, to methyl_HOMO_DN.cube and methyl_HOMO_UP.cube, and their LUMO counterparts to methyl_LUMO_DN.cube and methyl_LUMO_UP.cube. Similarly named files contain the orbitals just below the HOMO and just above the LUMO (not provided here, but generated during the calculation).</p> <p> </p> Table 1: Fill this table with the data found in the calculation output."},{"location":"tutorials/tutorial_5/tutorial/#visualisation-local-potential","title":"Visualisation [local potential]","text":"<p>Finally, let's try visualizing the local potential [sum of the ionic, Hartree (Coulomb) and XC potentials] with a contour plot, which is written out to methyl_potential.cube.</p> <p>Isosurface plots of potentials can be obtained similarly to the isosurface plots of densities. This can be accomplished by choosing <code>VolumeSlice</code> for <code>Drawing Method</code>. Try playing with <code>Slice Axis</code> and <code>Slice Offset</code> to get the hang of it. Admittedly, the quality of the contour plot is not too good, even if you set <code>Render Quality</code> to <code>High</code>. It is improved, however, when you create a production image. Try obtaining a composite CPK + isodensity + contour plot similar to the one shown here.</p> <p> </p> Fig.4: The local potential of the CH3 radical visualized in VMD."},{"location":"tutorials/tutorial_5/tutorial/#visualising-ngwfs-and-nnhos-for-c2sih6","title":"Visualising NGWFs and NNHOs for C<sub>2</sub>SiH<sub>6</sub>","text":"<p>In this example we will perform two sets of calculations on the C\\(_2\\)SiH\\(_6\\) molecule:</p> <p> </p> Fig.5: The C2SiH6 molecule. Visualization in VMD."},{"location":"tutorials/tutorial_5/tutorial/#prepreation_1","title":"Prepreation","text":"<p>The ONETEP input for this calcualtion are:</p> <ul> <li>Input file 1: C2SiH6_NGWF.dat</li> <li>Input file 2: C2SiH6_NNHO.dat</li> </ul> <p>Compared to the previous input file, the first input file has similar parameters (and, thus, keywords). However it also contains the <code>WRITE_NGWF_PLOT TRUE</code> keyword that allows output of selected NGWFs in the scalarfield formats we discussed earlier (<code>.cube</code> by default). The NGWFs that will be outputted are selected by the <code>species_ngwf_plot</code> block in which the species of atoms whose NGWFs are to be outputted are listed. In this example we output NGWFs of the Si atom and of the first H and C atoms (as written in the input coordinates). </p> <p>The second input file contains the additional keyword <code>NNHO TRUE</code> which instructs ONETEP to perform a same-centre rotation of the NGWFs to transform them to non-orthogonal natural hybrid orbitals (NNHOs). These contain the same information as the NGWFs but are more \"natural\" as they conform with chemical concepts, such as being directed towards chemical bonds, and physical concepts, as in several of their properties they resemble proper Wannier functions. The mixing of NGWFs to NNHOs is done according to the procedure by Foster and Weinhold <sup>3</sup>. For this calculation we will use the PBE GGA exchange-correlation functional (<code>XC_FUNCTIONAL PBE</code>).</p>"},{"location":"tutorials/tutorial_5/tutorial/#visualisation-ngwf-and-nnho","title":"Visualisation [NGWF and NNHO]","text":"<p>Run the calculation to completion with the two inputs (in separate directories), it should take no more than five minutes for each of them. </p> <p>Reference outputs are:</p> <ul> <li>output 1: C2SiH6_NGWF.out</li> <li>output 2: C2SiH6_NNHO.out</li> </ul> <p>Examine some of the NGWF and NNHO output files. As an example, below we show plots of the third function (NGWF or NNHO) of atom 2 (one of the carbons). Try to obtain similar plots.</p> <p> </p> Fig.6: A particular NGWF of the C2SiH6 molecule. Visualization in VMD. <p>You can observe that initially the function is a p-atomic orbital (as it is initialised by ONETEP). After the calculation the NGWF is rather distorted but still contains quite a lot of p character. The NNHO however is a mixture of all the 4 NGWFs of the carbon atom and is optimally pointed along the C-C bond. You can quantify these observations by comparing the two output files, C2SiH6_NGWF.out and C2SiH6_NNHO.out, which contain an <code>NGWF s/p/d/f Character Analysis</code> section towards the bottom of the file (thanks to the <code>NGWF_ANALYSIS TRUE</code> keyword in the input). You will see how much the NGWFs differ from the NNHOs. Of course all the other quantities (energies, Kohn-Sham orbitals, orbital energies, etc.) are independent of whether you use NGWFs or NNHOs. Check this by completing the table below.</p> <p> </p> Table.2: Fill this table with the data found in the calculation output. <p>Finally, examine the atomic population in the output files (we have asked for it using the keyword <code>POPN_CALCULATE TRUE</code> in the input) and confirm that the charges on each atom are consistent with their relative electronegativities.</p>"},{"location":"tutorials/tutorial_5/tutorial/#nanostructure","title":"Nanostructure","text":"<p>Let us now see how to set up and visualize a calculation on a nanostructure whose size is in the region where conventional cubic scaling codes become very inefficient, while linear-scaling codes like ONETEP are still at the beginning of their capabilities. We will perform a calculation on the following \"nano-peapod\" structure, which consists of a C<sub>70</sub> fullerene inside a single repeat-unit of a (10,8) carbon nanotube.</p> <p> </p> Fig.7: The local potential, and the HOMO and LUMO orbitals of the system under study. Visualization in VMD."},{"location":"tutorials/tutorial_5/tutorial/#prepreation_2","title":"Prepreation","text":"<p>The (10,8) is a chiral nanotube with 488 atoms in each repeat-unit, so the peapod input consists of 558 atoms, with no symmetry, in a unit cell of 20.0 x 20.0 x 33.27 (angstroem), which is equivalent to 37.795 x 37.795 x 62.874 (Bohr).</p> <p>The ONETEP input can be downloaded:</p> <ul> <li>Input: C70_in_10-8.dat. </li> </ul> <p>Note that in this input fiel, we impose a density kernel cut-off of 30.0 Bohr (<code>KERNEL_CUTOFF 30.0 Bohr</code>) in order to achieve linear-scaling behaviour.</p> <p>This calculation is best run on a parallel computer, but you can run it on a desktop machine where it should complete in about two-three hours. It took just under 8 minutes when run on 5 nodes (360 CPU cores) in 2023. If you do not want to wait or do not have the sufficient resources, here's the reference output: C70_in_10-8.out.</p>"},{"location":"tutorials/tutorial_5/tutorial/#visualisation","title":"Visualisation","text":"<p>Let us start by examining the output file. At the beginning of the calculation the filling (the opposite of sparsity) of various matrices is reported. You will notice that the density kernel is not 100% full as a consequence of the cut-off that is imposed in the input. Information about the psinc grid sizes is also provided, including the actual plane-wave cut-off to which they correspond and the size of the FFT box. The calculation converges in 7 NGWF iterations, which is the point where the NGWF gradient threshold set in the input (<code>NGWF_THRESHOLD_ORIG 0.00003</code>) has been satisfied. Normally you'd likely use a tighter threshold for extra accuracy (the default is <code>2E-6</code>).</p> <p>As before, a range of properties are calculated (<code>DO_PROPERTIES T</code>). As an example, you can examine the total potential (the sum of ionic, Hartree and exchange-correlation potentials) which is outputted to the file <code>C70_in_10-8_PROP_potential.cube</code>. We do not provide this file here due its size. A contour plot on a plane containing the nanotube axis of the potential will look similar to what you see below, which is compatible with the chiral nature of the nanotube and reveals also the asymmetric way in which the oblong C<sub>70</sub> is is located inside it.</p> <p> </p> Fig.8: The local potential of the system under study. Visualization in VMD. <p>Red regions correspond to large and positive values of the potential (standard electrostatic conventions) and reveal the location of nuclei, whose distance from the plane varies along the axis of the tube, as a result of the chirality. You can go on and explore other properties of the nano-peapod from the C70_in_10-8.out file and the other output files that were produced by the properties calculation.</p> <p>If you are in an ambitious mood, try creating a fancy plot showing the structure of the nano-peapod system with its HOMO and LUMO orbitals and a contour plot of the potential, similar to the one below.</p> <p> </p> Fig.9: The local potential, and the HOMO and LUMO orbitals of the system under study. Visualization in VMD. <p>This concludes tutorial 5.</p> image/svg+xml <ol> <li> <p>VMD (Visual Molecular Dynamics) is a free of charge visualization package    available from https://www.ks.uiuc.edu/Research/vmd\u00a0\u21a9</p> </li> <li> <p>The colouring is described here: https://en.wikipedia.org/wiki/CPK_coloring.\u00a0\u21a9</p> </li> <li> <p>J. P. Foster and F. Weinhold, J. Am. Chem. Soc. 102, 7211 (1980).\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_6/tutorial/","title":"Tutorial 6","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 6"},{"location":"tutorials/tutorial_6/tutorial/#tutorial-6-time-dependent-dft","title":"Tutorial 6: Time-Dependent DFT","text":"<p> Version: all versions  Tim Zuehlsdorf;   </p>"},{"location":"tutorials/tutorial_6/tutorial/#tddft-in-onetep","title":"TDDFT in ONETEP","text":"<p>This tutorial aims at showing how to run a simple linear-response TDDFT calculation in ONETEP. Linear-response TDDFT is the main method of choice when computing optical excitations for large system sizes. In this formalism, excitation energies are directly obtained as the solutions to an effective eigenvalue equation. The approach implemented in ONETEP can be made to scale fully linearly with systems size, allowing for the computation of excitations in systems containing thousands of atoms.</p> <p>In linear-response TDDFT, an excitation is expressed through a transition vector that can be written in the basis of all possible Kohn-Sham transtions from occupied to unoccupied states. Thus unlike in standard ground state DFT, where a good representation of the occupied KohnSham states is sufficient  to obtain accurate results, in a TDDFT calculation an equally good representation of a subset of the unoccupied Kohn-Sham space is vital. Since the ONETEP support functions are optimised in situ to ideally represent the occupied manifold, they generally provide a relatively poor description of the unoccupied manifold, making them insufficient for describing excitations in a linear-response framework. In practice, this problem is removed by optimising a second set of support functions to ideally span a low energy subset of the conduction space in a post-processing step after a <code>Singlepoint</code> calculation. Together, the two sets of support functions form an ideal representation of any given low energy excitation, thus enabling efficient iand accurate TDDFT calculations in very large systems.</p>"},{"location":"tutorials/tutorial_6/tutorial/#setting-up-a-tddft-calculation-in-onetep","title":"Setting up a TDDFT calculation in ONETEP","text":"<p>A TDDFT calculation in ONETEP thus proceeds in three separate steps:</p> <ul> <li>A standard ground state calculation using <code>Task: Singlepoint</code>. The code will write out <code>.dkn</code> and <code>.tightbox_ngwfs</code> files containing the valence density kernel and the NGWF support functions.</li> <li>A conduction optimisation using <code>Task: Cond</code>. The code will read in the converged <code>.dkn</code> and <code>.tightbox_ngwfs</code> files from the ground-state optimisation and perform a postprocessing <code>conduction optimisation</code> of some low energy part of the conduction space manifold. It will write out <code>.dkn_cond</code> and <code>.tightbox_ngwfs_cond</code> files containing an effective density kernel for the low energy conduction space, as well as the NGWF support functions for the conduction space.</li> <li>A TDDFT calculation using <code>Task: Lr_tddft</code>. The code will read in the density kernels and support functions for both the ground state and the conduction space calculations and then calculate the lowest n excitations of the system, where n is determined by the keyword <code>lr_tddft_num_states</code>.</li> </ul> <p>In practice, it is possible to string these tasks together using <code>Task: Singlepoint Cond Lr_tddft</code> in an input file that lists appropriate keywords for all three calculation types. The tasks will be performed one after another, without the user having to restart the calculation in between.</p>"},{"location":"tutorials/tutorial_6/tutorial/#an-nn-substituted-nanoribbon","title":"An NN-substituted nanoribbon","text":"<p>We turn to a simple example of an excited state calculation in a periodic system, namely that of an infinitely long graphene nanoribbon with two nitrogen substitutions. We will aim to compute excited states that are associated with the substitution and that are thus relatively localised in character. In a first step, we aim to build an input file for a pristine graphene nanoribbon in periodic boundary conditions. A primitive unit cell for the nanoribbon in question can be found below:</p> <pre><code> %block positions_abs\n C 10.90 10.0 0.000\n C 13.58 10.0 0.000\n H 7.50 10.0 2.327\n C 9.56 10.0 2.327\n C 14.93 10.0 2.327\n H 16.99 10.0 2.327\n %endblock positions_abs\n</code></pre> <p>To generate an appropriate input file, copy the above primitive unit cell block into a new input file called <code>ribbon.dat</code>. ONETEP does not make use of any k-point sampling and all calculations are effectively done at the \\(\\Gamma\\)-point. Therefore, in order to accurately simulate periodic structures it is necessary to simulate supercells rather than primitive cells as would be done in standard plane wave DFT codes. An appropriate supercell from the above primitive cell can be created by repeating the primitive cell 7 times along the z-axis, translating the z-coordinates of the atoms by the lattice vector of the primitive unit cell. The resulting supercell should contain 48 atoms in total.</p> <p>Now create an appropriate <code>%block lattice_cart</code> for the system. The length of the supercell is specified by the length of your primitive cell and the number of repeats of that cell. However, the size of the unit cell in the x and y direction is free to specify by the user. Since the ONETEP method uses periodic boundary conditions in all three directions, it is necessary to include enough vacuum in the x and y direction of the simulation cell to prevent it from interacting with its periodic neighbours. In this case, about 20 a<sub>0</sub> of vacuum between any atoms of different periodic images is a reasonable length.</p> <p>Using the lessons learnt from previous tutorials add a <code>%block species</code> and <code>%block species_pot</code> block to your input file. Choose an appropriate NGWF radius (try 8 a<sub>0</sub>) and kinetic energy cutoff (around 600 eV) for your calculation. When choosing the NGWF radius, note that ONETEP will not allow you to pick an NGWF diameter that is larger than the dimensions of your simulation cell, as this would cause an NGWF to interact with its periodic image. Finally, perform a singlepoint calculation of the system. You can add a keyword <code>do_properties: T</code> to the input file. This will trigger the code to perform a properties calculation, write out a file <code>.val_bands</code> containing all Kohn-Sham energies and write cube files of selected Kohn-Sham states around the band gap.</p>"},{"location":"tutorials/tutorial_6/tutorial/#conduction-optimisation","title":"Conduction optimisation","text":"<p>Once the ground state calculation is finished, it is necessary to perform a conduction optimisation. First, set <code>Task: Cond</code> and add a new block <code>%block species_cond</code> to the input file. This block is made up in an identical way as <code>%block species</code> and specifies the number of support functions and their radius in the conduction optimisation. In many practical examples, it is often advisable to choose a larger NGWF radius for the conduction optimisation than for the ground state calculation, especially if one is interested in lightly bound states, as unoccupied Kohn-Sham states tend to be more diffuse than occupied ones (try 10 a<sub>0</sub> for example).</p> <p>A second keyword required for the conduction optimisation is the number of conduction states that should be explicitly optimised (<code>cond_num_states</code>). It is normally advisable to optimise only well-bound states as unbound states are difficult to describe with localised orbitals. In order to do so, have a look at the file <code>.val_bands</code> and count the number of Kohn-Sham states with negative energy that are unoccupied. Note that <code>cond_num_states</code> expects the number of electrons to be optimised as an input, thus in order to optimise the five lowest unoccupied Kohn-Sham states in a spin-degenerate system, one should choose <code>cond_num_states: 10</code>.</p> <p>Once you have run the calculation, have a look at the output. You will find that ONETEP has generated a number of files such as cube files of unoccupied Kohn-Sham states expressed in terms of the optimised conduction NGWFs.</p>"},{"location":"tutorials/tutorial_6/tutorial/#tddft-calculation","title":"TDDFT calculation","text":"<p>We can now perform a full ONETEP TDDFT calculation of the system at hand. To do so, set <code>Task: Lr_tddft</code> in the input file. Furthermore, add the keywords <code>lr_tddft_num_states: 6</code>, <code>lr_tddft_write_densities: T</code> and <code>lr_tddft_analysis: T</code>. The code will compute the lowest 8 singlet excitations of the system and generate cube files for the electron, hole and transition density for each excitation that can be visualised. Furthermore <code>lr_tddft_analysis: T</code> triggers a breakdown of the converged TDDFT eigenvectors into Kohn-Sham transitions, allowing you to study which are the dominant transitions for each excitations.</p> <p>Once you have performed the TDDFT calculation, look at the output file. You will see that the excitation energies and oscillator strengths for each of the excitations are printed out, as well as a detailed breakdown of excitation energies into Kohn-Sham transtions. Have a look at some of the cube files produced. Where are the excitations located in the system?</p>"},{"location":"tutorials/tutorial_6/tutorial/#nitrogen-substitution","title":"Nitrogen substitution","text":"<p>We can now move on from the case of the pristine nanoribbon to one with two nitrogen substitutions.  For this purpose, copy the input file <code>ribbon.dat</code> to a new file <code>ribbon_NN.dat</code>. In that file, remove two C-H from the <code>%block positions_abs</code> that are opposite to each other in the ribbon, and replace them by two N at the same positions where the C were located.</p> <p> </p> Left: Pristine nanoribbon. Right: Nanoribbon with two carbons and two hydrogens substituted for two nitrogens. <p>Note that in order to run the calculation, you will have to add the nitrogen species to the  <code>%block species_pot</code>, <code>%block species</code> and <code>%block species_cond</code> blocks.  Change the task to <code>Task: Singlepoint Cond Lr_tddft</code>. The code will run a ground state and conduction optimisation, followed by a TDDFT calculation for the full system. Have a look at the output. How do the excited states change due to the nitrogen substitutions?  Where is each excited state located within the system?</p>"},{"location":"tutorials/tutorial_6/tutorial/#additional-tasks","title":"Additional tasks","text":"<p>Substituting nitrogen atoms in the same place as carbon atoms does not yield a relaxed ground state structure, as the N-C bond is not of the same length as the C-C bond. Thus in order to obtain more realistic results for the substituted system, perform a geometry optimisation (see tutorial 4), followed by a ground state, conduction and TDDFT calculation of the full system. How do the results change? Furthermore, create a system where the nitrogen atoms are not substituted at exactly opposite positions in the structure, but an asymmetry along the z-axis is introduced. How does the character of the low energy excitations change?</p>"},{"location":"tutorials/tutorial_6/tutorial/#input-files","title":"Input files","text":"<p>All the files needed for the simulation can be downloaded from:</p> <ul> <li>ribbon_pristine.dat</li> <li>ribbon_pristine_NN.dat</li> <li>ribbon_pristine.out</li> <li>ribbon_pristine_NN.out</li> <li>carbon.recpot</li> <li>hydrogen.recpot</li> <li>nitrogen.recpot</li> </ul> image/svg+xml"},{"location":"tutorials/tutorial_8/tutorial/","title":"Tutorial 8","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 8"},{"location":"tutorials/tutorial_8/tutorial/#tutorial-8-implicit-solvation-visualisation-and-properties-protein-ligand-free-energy-of-binding-for-the-t4-lysozyme","title":"Tutorial 8: Implicit solvation, visualisation and properties: Protein-ligand free energy of binding for the T4 lysozyme","text":"<p> Version: all versions  Lennart Gundelach; Jacek Dziedzic </p>"},{"location":"tutorials/tutorial_8/tutorial/#introduction","title":"Introduction","text":""},{"location":"tutorials/tutorial_8/tutorial/#protein-ligand-free-energies-of-binding","title":"Protein-Ligand Free Energies of Binding","text":"<p>The binding free energy is a measure of the affinity of the process by which two molecules form a complex by non-covalent association. An example of this, of central importance in biology, is the binding of a ligand to a protein. Many methods to computationally approximate the binding free energies of protein-ligand interactions have been proposed with the ultimate goal of computationally predicting small molecule drug candidates which bind strongly to the protein of interest.</p>"},{"location":"tutorials/tutorial_8/tutorial/#quantum-mechanics-in-binding-free-energies","title":"Quantum Mechanics in Binding Free Energies","text":"<p>A key limitation common to most computational methods of estimating binding free energies is the assumption of the validity of classical mechanics. The atoms and electrons that constitute biological molecules, like proteins, are, however, governed by the laws of quantum mechanics. Charge transfer, polarization and non-local interactions are not captured by traditional classical mechanical force-fields. Thus, a true description of protein-ligand binding requires a quantum mechanical (QM) treatment of the problem. In theory, a full, ab-initio QM approach would be system-independent, parameter-free and would describe the full spectrum of physical phenomena at work.</p> <p>Unfortunately, high-level QM methods like coupled-cluster (CC) are prohibitively expensive and often have cubic or worse scaling with system size. Thus, even the ligands alone are often too large for routine calculations with these methods.</p>"},{"location":"tutorials/tutorial_8/tutorial/#linear-scaling-density-functional-theory","title":"Linear Scaling Density Functional Theory","text":"<p>Due to the cubic scaling of conventional density functional theory, full-protein calculations on many thousands of atoms are not feasible. To study larger systems, linear-scaling versions of DFT have been developed <sup>1</sup>. The ONETEP code <sup>7</sup> is one such linear-scaling DFT implementation, exploiting hybrid MPI-OMP parallelism <sup>8</sup> for efficient and scalable calculations. The unique characteristic of ONETEP is that even though it is linear-scaling, it is able to retain large basis set accuracy as in conventional cubic-scaling DFT calculations. The implicit solvation model is a minimal-parameter Poisson-Boltzmann (PB) based model which is implemented self-consistently as part of the DFT calculation <sup>2</sup> <sup>9</sup> and uses the smeared-ion formalism and electron-density iso-surfaces to construct solute cavities.</p>"},{"location":"tutorials/tutorial_8/tutorial/#t4-lysozyme","title":"T4 Lysozyme","text":"<p>The protein under investigation in this tutorial is a double mutant of the T4 lysozyme (L99A/M102Q). This protein has been artificially mutated to form a buried polar binding site and has served as a model or benchmark system for various protein-ligand binding free energy studies <sup>6</sup>. Although this protein is not directly pharmaceutically relevant, it is a useful model system due to it its relatively small size (2500 atoms), structural rigidity and well-defined, buried binding site, which can accommodate a wide variety of ligands. Fig.1 shows the ligand catechol inside the buried binding site of the T4 lysozyme L99A/M102Q mutant. PDB files of the complex, host and ligand are provided as part of this tutorial for you to visualize the system. The picture shown uses the <code>NewCartoon</code> representation for the protein with coloring based on secondary structure and <code>CPK</code> (ball-and-stick) for the ligand with element based coloring.</p> <p> </p> Fig.1 Catechol bound in the buried binding site of the T4 lysozyme L99A/M102Q double mutant. Visualization in VMD."},{"location":"tutorials/tutorial_8/tutorial/#qm-pbsa-binding-free-energies","title":"QM-PBSA Binding Free Energies","text":"<p>In this tutorial we will calculate the binding free energy of catechol to the T4 lysozyme L99A/M102Q mutant. We will employ a simplified QM-PBSA approach <sup>3</sup> <sup>4</sup> on a single snapshot of the protein-ligand complex.</p> <p>The QM-PBSA approach is a quantum-mechanical adaptation of traditional MM-PBSA, which is an end-point, implicit solvent, binding free energy method. In this approach, the binding free energy is given by</p> \\[    \\Delta G_{\\textrm{bind}}= G_{\\textrm{complex}} - G_{\\textrm{host}} - G_{\\textrm{ligand}} \\tag{1}, \\] <p>where $G_{\\textrm{complex}}, \\(G_{\\textrm{host}}\\), and \\(G_{\\textrm{ligand}}\\) is the free energy of, respectively, the complex, host and ligand in an implicit solvent. Each of these can be decomposed into three terms,</p> \\[    G=E + \\Delta{}G_{\\textrm{solv}} - TS \\tag{2}, \\] <p>where \\(E\\) is the total gas-phase energy, \\(\\Delta{}G_{\\textrm{solv}}\\) is the free energy of solvation and \\(-TS\\) is an entropy correction term. In this tutorial, the entropy term will be ignored, as it is usually calculated in other programs using normal mode analysis. The linear-scaling DFT code ONETEP will be used to calculate the gas-phase and solvation free energy of the complex, host and ligand at a fully quantum-mechanical level.</p>"},{"location":"tutorials/tutorial_8/tutorial/#setting-up-the-calculations","title":"Setting up the calculations","text":"<p>We will set up three separate calculations, one each for the protein-ligand complex, the protein (host) and catechol (ligand). The structure of the complex was taken from a molecular dynamics simulation of the complex used in two QM-PBSA studies on this system <sup>3</sup> <sup>4</sup>. The structure of the unbound ligand and host were obtained from the complex by deletion of the respective molecules. Apart from the atomic coordinates, we must specify the details of the ONETEP single-point calculations, provide pseudopotentials for the atoms present in the system and adapt job submission scripts to run the calculations on the supercomputer of choice.</p>"},{"location":"tutorials/tutorial_8/tutorial/#the-input-files","title":"The input files","text":"<p>The ONETEP input file, referred to as the <code>.dat</code> file, contains two main elements: 1) the coordinates and atom types of the system (i.e the structural information) and 2) the details of the calculation. Due to the large system size, we have split theses two components across separate files: the <code>.dat</code> file, which contains the structural information, and a <code>.header</code> file which contains instructions for ONETEP. This header file is included in the <code>.dat</code> file via the command <code>includefile</code>. All information could also be contained in a single <code>.dat</code> file; however, the use of a separate header file can make it easier to set up hundreds or even thousands of calculations which differ only in the coordinates and not the calculation settings.</p>"},{"location":"tutorials/tutorial_8/tutorial/#dat-file","title":"<code>.dat</code> file","text":"<p>The two blocks included in the <code>.dat</code> file are <code>lattice_cart</code> and <code>positions_abs</code>, which specify the simulation cell and absolute positional coordinates of each atom within the simulation cell, respectively. The <code>includefile</code> command on the first line specifies the header file to include for the calculation.</p>"},{"location":"tutorials/tutorial_8/tutorial/#header-file","title":"<code>.header</code> file","text":"<p>This <code>.header</code> file contains all further details of the ONETEP calculation. The <code>species</code> block specifies the name, element, atomic number, number of NGWFs and the NGWF radius for each atom type in the system. The <code>species_pot</code> lists the names of the pseudopotential files for each atom type. The rest of the file consists of ONETEP keywords which control the details of the calculation. The provided header files are fully commented, and details on each keyword are given in the ONETEP keyword directory (http://onetepkeywords.icedb.info/onetepdoc). We will be performing single-point energy calculations using the PBE exchange-correlation functional, the D2 dispersion correction and ONETEP\u2019s minimal paramater implicit solvent model. The calculation will output verbose detail and an <code>.xyz</code> file for easy visualization. The total system charge is +9 for the complex and host and 0 of the ligand. The implicit solvent is set to use the default parameters for water.</p>"},{"location":"tutorials/tutorial_8/tutorial/#submission-scripts","title":"Submission Scripts","text":"<p>Due to the large system size of over 2500 atoms, these single-point calculations can only be run on a supercomputer. Thus, a submission script appropriate for the HPC environment you are working on will be necessary. The standard distribution of ONETEP provides sample submission scripts for a variety of HPC systems. These can be found in your ONETEP directory under <code>hpc_resources</code>.</p> <p>We recommend to run the complex and host calculations on multiple compute nodes, making full use of the hybrid MPI-OMP capabilities of ONETEP. On the national supercomputer ARCHER2, the use of 4 compute nodes (128 cores each) with 32 MPI processes and 16 OMP threads per process results in a wall-time of about 8 hours. Due to the much smaller size of the ligand, the calculation on the ligand in solvent should be limited to a single node, with at most 10 MPI processes.</p>"},{"location":"tutorials/tutorial_8/tutorial/#evaluating-the-outputs","title":"Evaluating the Outputs","text":"<p>Upon successful completion of the calculations, we will examine the three <code>.out</code> files created. Each of these files contains the full details and log of the calculation, as well as the final results and some timing information. While much information about the system can be gained from the output files, we will focus first only on the final results necessary to estimate the binding free energy of the ligand, catechol, to the protein.</p> <p> </p> Table.1 Calculating the binding free energy of catechol to the protein. <p>As outlined in Eqs. 1 and 2 we need to calculate the total free energy of the complex, host and ligand before subtracting the total energy of the host and ligand from that of the complex. As stated before, we will be ignoring any entropy contributions in this tutorial. The total energy is then the sum of the total gas phase energy and the solvation free energy. These energies are summarized in an easy to read section at the very end of the output files, just before the timing information. To find it, search the output file for <code>Total energy in solvent</code>. This section breaks down the different energy contributions and states the total energies in vacuum (gas phase) and in solvent as well as the solvation free energy. Table.1 summarizes the energy values obtained. To estimate the binding free energy we simply apply Eq. 1 to yield:</p> \\[   \\begin{aligned}   \\Delta G_{\\textrm{bind}}&amp;=G_{\\textrm{complex}}-G_{\\textrm{host}}-G_{\\textrm{ligand}}=\\\\   &amp;=-7374799.3 -(-7330822.5) - (-43949.7) = -27.1 \\textrm{kcal/mol}   \\end{aligned}   . \\] <p>Thus, the estimated binding energy of catechol to the T4 lysozyme is -27.1 kcal/mol. However, there are a number of severe limitations of this estimate: 1) the entropy correction term \\(-TS\\) has been neglected; 2) only a single snapshot was evaluated; 3) the implicit solvent model incorrectly interprets the buried cavity in the T4 lysozyme, and 4) the QM-PBSA method is designed to calculate relative binding free energies between similar sets of ligands. For an in depth look at the full application of the QM-PBSA binding free energy method to 7 ligands binding to the T4 lysozyme and a discussion of the errors, convergence and limitations of the method, please consult our recent publication <sup>4</sup>.</p>"},{"location":"tutorials/tutorial_8/tutorial/#cavity-correction","title":"Cavity Correction","text":"<p>The minimal-parameter PBSA solvent-model implemented in ONETEP incorrectly handles the buried cavity in the T4 lysozyme (L99A/M102Q). This is a known issue for solvent models based on the solvent accessible surface area, and has been described in detail in 2010 by Genheden et al. <sup>10</sup>, and in 2014 by Fox et al. <sup>3</sup>.</p> <p>In the un-complexed protein calculation, i.e the host, the surface area of the interior of the buried binding site is counted towards the solvent accessible surface area (SASA) used to calculate the non-polar solvation term. Thus, the non-polar term of just the protein is larger than that of the complex indicating the formation of a larger cavity in the solvent. Conceptually, the SASA model creates an additional, fictitious, cavity in the solvent with the SASA of the buried binding site. Because the non-polar term of both the protein and complex are known, a post-hoc cavity-correction may be applied to remove the additional (spurious) contribution of the buried cavity to the non-polar solvation energy. A full derivation is provided in <sup>3</sup>.</p> \\[    E_{\\textrm{cav-cor}}=7.116(E^{\\textrm{host}}_{\\textrm{non-polar}}-E^{\\textrm{complex}}_{\\textrm{non-polar}})=7.116(289.5 - 286.2) = 23.5 \\text{ kcal/mol}.        \\label{eq:cav-cor} \\] <p>Applying the cavity correction term calculated above to the binding free energy, we obtain a cavity-corrected binding free energy of \\(-27.1 + 23.5 = -3.6\\) kcal/mol. For comparison, the experimental binding energy of catechol to the T4 lysozyme is -4.4 kcal/mol. It should however be noted, that the close correspondence of this single snaphot QM-PBSA binding free energy to the absolute experimental energy is likely a lucky coincidence, as the QM-PBSA method is mainly applicable to relative binding free energies and the entropy correction term has not yet been included.</p>"},{"location":"tutorials/tutorial_8/tutorial/#properties","title":"Properties","text":"<p>We will now show how a number of useful properties of the system can be studied through a properties calculation. In the interest of saving computational time, and for clarity of presentation, we will use the ligand system as an example.</p> <p>Add the following keywords to the <code>.header</code> file of the ligand calculation: <pre><code> do_properties T\n dx_format T\n cube_format F\n</code></pre>  and run it again.</p> <p>The first of these keywords instructs ONETEP to perform a properties calculation towards the end of the run. This will calculate, among others, Mulliken charges on the atoms, bond lengths, the HOMO-LUMO gap, the density of states (DOS) and some grid-based quantities, such as the HOMO and LUMO canonical molecular orbitals, electronic charge density and potential. The grid-based quantities (often called scalarfields) can be output in three different formats: <code>.cube</code>, <code>.dx</code>, and <code>.grd</code>. By default <code>.cube</code> files are written, and not the other two formats. In this example we switch off <code>.cube</code> output and turn on <code>.dx</code> output. This is effected by the last two keywords.</p> <p>Once your calculation finishes, you will see that quite a number of <code>.dx</code> files have been produced:</p> <ul> <li> <p><code>xxx_HOMO.dx</code> \u2013 density of the canonical HOMO orbital.</p> </li> <li> <p><code>xxx_LUMO.dx</code> \u2013 density of the canonical LUMO orbital.</p> </li> <li> <p><code>xxx_HOMO-n.dx</code> \u2013 density of the n-th    canonical orbital below HOMO.</p> </li> <li> <p><code>xxx_LUMO+n.dx</code> \u2013 density of the n-th    canonical orbital above LUMO.</p> </li> <li> <p><code>xxx_density.dx</code> \u2013 the electronic density of the entire system.</p> </li> <li> <p><code>xxx_potential.dx</code> \u2013 the total potential (ionic + Hartree + XC) in    the system.</p> </li> <li> <p><code>xxx_electrostatic_potential.dx</code> \u2013 the electrostatic potential    (ionic + Hartree) in the system.</p> </li> </ul> <p>These files correspond to the calculation in solvent. There will be a second set of <code>.dx</code> files with <code>vacuum</code> in their names \u2013 these correspond to the calculation in vacuum. This lets you study and visualize in-vacuum and in-solvent properties separately and to perform comparisons between the two. Here, you can expect the scalarfields to be rather similar between in-vacuum and in-solvent because the ligand is charge-neutral and polarizes the solvent only very slightly.</p> <p>There is a separate tutorial (Tutorial 5) devoted to visualization. You can use the skills taught there to create fancy visualizations of the properties of your choice. Here we will only show how to produce a neat visualization of the electronic density coloured by the electrostatic potential using VMD.</p> <p>Load the electronic density and the electrostatic potential into one molecule, and the atomic coordinates into a separate molecule. This will make it easier treat the scalarfields and the atomic coordinates separately. To achieve this, issue:</p> <pre><code>   vmd ligand_2001_density.dx ligand_2001_electrostatic_potential.dx -m ligand_2001.xyz\n</code></pre> <p>Once VMD loads the files, go to <code>Graphics/Representations</code>. Ensure <code>Selected Molecule</code> (at the top of the window) is the <code>.xyz</code> file (atomic coordinates). Under <code>Drawing Method</code> Choose <code>CPK</code> \u2013 this will create a ball-and-stick drawing of the ligand. Switch <code>Selected Molecule</code> to the <code>.density.dx</code> file to operate on the electronic density scalarfield. Under <code>Drawing Method</code> choose <code>Isosurface</code> if it is not chosen already. Choose an <code>Isovalue</code> of <code>0.1</code> to pick a reasonable density isovalue to plot. Under <code>Coloring Method</code> choose <code>Volume</code> (you might need to scroll to the very bottom to get there). In the tiny drop-down window to the right of <code>Coloring Method</code> switch from scalarfield 0 (the density itself) to scalarfield 1 (the potential) \u2013 this will colour the density with the potential. For <code>Material</code> (further to the right) choose <code>Glass2</code> \u2013 this will choose a somewhat translucent material that will let us see both the ball-and-stick model and the electronic density. Under <code>Draw</code> in the bottom-right of the window, choose <code>Solid Surface</code> instead of <code>Points</code>. Finally, let\u2019s change the range of the potential to the kinds of values that occur at the distance from the molecule at which our electronic density isosurface lies. These have been determined by trial and error. There are four tabs just above <code>Coloring Method</code>. Somewhat counterintuitively, switch to <code>Trajectory</code>, where, under <code>Color Scale Data Range</code> you can enter the minimum and maximum values for the potential (in eV). Enter <code>-1</code> in the left field and <code>1.5</code> in the right field and click <code>Set</code>. This should give a nice representation, which you can then rotate and translate to your liking using the mouse in the <code>OpenGL Display</code> window. Once you are satisfied, you can render the final image by going to <code>File/Render</code>. In the top drop-down menu choose <code>Tachyon</code> and click on <code>Start Rendering</code>. After a short while you will get a <code>.tga</code> (\u201cTARGA format\u201d) file in the directory you are working in. It will look more or less like the graphics in Fig.2. Most graphics manipulation programs and graphics viewers read <code>.tga</code> files. If you have <code>ImageMagick</code> installed, you can use it to convert the image to a more common format, like <code>.png</code>:</p> <pre><code>   convert vmdscene.dat.tga vmdscene.dat.png\n</code></pre> <p> </p> Fig.2 Visualization of the ligand in VMD. A ball-and-stick model of the    molecule is shown, together with an isosurface of the electronic    density, coloured by the electrostatic potential."},{"location":"tutorials/tutorial_8/tutorial/#atomic-charges","title":"Atomic charges","text":""},{"location":"tutorials/tutorial_8/tutorial/#mulliken-population-analysis","title":"Mulliken population analysis","text":"<p>By default, during a properties calculation, ONETEP performs Mulliken population analysis, calculating partial atomic charges. The charges are written to the output file, in a table that looks like this:</p> <pre><code>       Mulliken Atomic Populations\n       ---------------------------\n   Species  Ion    Total   Charge (e)\n   ==================================\n     O      1       6.750     -0.750\n     H      2       0.448      0.552\n     C      3       3.817      0.183\n   ...\n   ==================================\n</code></pre> <p>The partial charges (in the electrons-are-negative sign convention) are output in the last column.</p> <p>Mulliken population analysis has a number of drawbacks, chief among which is that it depends on the basis set used and there is no well-defined complete basis set limit. Below we discuss two alternative schemes that can be used in ONETEP: Natural Population Analysis (NPA) and Density-Derived Electrostatic and Chemical (DDEC) analysis.</p>"},{"location":"tutorials/tutorial_8/tutorial/#natural-population-analysis","title":"Natural Population Analysis","text":"<p>In Natural Population Analysis the set of non-orthogonal, optimized NGWFs is transformed into a set of orthogonal atom-centered Natural Atomic Orbitals (NAOs). This approach lets empty, highly-diffuse orbitals distort to achieve orthogonality with their more highly-preserved occupied counterparts, ensuring the final NAO population is stable with respect to basis set size. More details, and references to papers on the method, can be found in the documentation for this functionality -- chapter \"Population Analysis\" in the main ONETEP documentation.</p> <p>To perform Natural Population Analysis in lieu of Mulliken population analysis, add the following keyword to your previous ligand calculation: <code>write_nbo T</code> and run it again. Keep the three keywords you added  last time. Once your calculation completes you will find the results of NPA in your output file. They will look like this:</p> <pre><code>   ================================================\n                  Natural Population\n   ------------------------------------------------\n    Summary\n   ------------------------------------------------\n      Atom        Population (e)      Charge (e)\n   ------------------------------------------------\n    O        1         6.7313861      -0.7313861\n    H        2         0.4487370       0.5512630\n    C        3         3.7852506       0.2147494\n   ...\n   ------------------------------------------------\n</code></pre>"},{"location":"tutorials/tutorial_8/tutorial/#density-derived-electrostatic-and-chemical-ddec-analysis","title":"Density-Derived Electrostatic and Chemical (DDEC) analysis","text":"<p>ONETEP uses the DDEC3 method [Manz2012]_ to effect atoms-in-molecule electron density partitioning, producing partial charges, as well as higher multipoles (if desired), which are both chemically meaningful and give a faithful reproduction of the electrostatic potential of the QM system. More details, and references to papers on the method, can be found in the documentation at www.onetep.org/pmwiki/uploads/Main/Documentation/ddec.pdf.</p> <p>To perform DDEC analysis in lieu of Mulliken population analysis, add the following keyword to your previous ligand calculation:</p> <pre><code>ddec_calculate T\n</code></pre> <p>You will also need to add a <code>block ddec_rcomp</code> that will specify where the reference ion densities can be found. You will need two reference density files for every atomic species in your system \u2013 one for the core and one for the total density, except for H and He which only require the total density file. The reference density files for a number of often-found elements can be found in the <code>c2_refdens</code> directory of your ONETEP installation. Fortunately all the files necessary for our ligand calculation (so, reference densities for C, H and O) are already there. Add the following block to your ligand input file:</p> <pre><code>   %block ddec_rcomp\n   H ALL \"H_c2.refconf\"\n   O ALL \"O_c2.refconf\"\n   O CORE \"O_c2.coreconf\"\n   C ALL \"C_c2.refconf\"\n   C CORE \"C_c2.coreconf\"\n   %endblock ddec_rcomp\n</code></pre> <p>and copy the five files listed in the block from the <code>c2_refdens</code> directory to where your calculation resides. The documentation explains where you can find reference density files for other elements, should you ever need them.</p> <p>Once you re-run your ligand calculation, you will find the results of DDEC analysis towards the end of your output file. They will look like this:</p> <pre><code>   ------------------------------------------------\n                DDEC Charges (X=0.21)\n   ------------------------------------------------\n      Atom        Population (e)      Charge (e)\n   ------------------------------------------------\n    O        1         8.5534066      -0.5534066\n    H        2         0.5775414       0.4224586\n    C        3         5.8305022       0.1694978\n   ...\n   ------------------------------------------------\n</code></pre>"},{"location":"tutorials/tutorial_8/tutorial/#comparison-of-mulliken-npa-and-ddec-charges","title":"Comparison of Mulliken, NPA and DDEC charges","text":"<p>The three approaches for calculating partial charges are compared in Table.2. Mulliken charges are, in general, the most pronounced out of the three, while DDEC partial charges are overall smaller in absolute value. The predictions of NPA are rather close to Mulliken analysis, while DDEC differs more from the first two.</p> <p> </p>    Table.2 Comparison of three approaches for calculating partial charges for the ligand.    <p>But... tables are boring. How can we visualize the charges using VMD? This is not as straightforward as we would like. The structure (atomic coordinates) is contained in the <code>.xyz</code> file, but the charges are not. Some programs can visualize a quantity added in an extra column in the <code>.xyz</code> file (which would become something like an <code>.xyzq</code> file), but not VMD, at least not easily.</p> <p>Fortunately VMD can read a different format named <code>.vtf</code>, which contains both the atomic coordinates and some scalar quantity, like charge. It is easy to convert an <code>.xyz</code> file and a list of charges to a <code>.vtf</code> file. We provide a simple <code>bash</code> script with this tutorial that does exactly that. It scans a ONETEP <code>.out</code> file for charge information (be it Mulliken, NPA or DDEC charges) and extracts the values of the charges on all atoms. It then looks for a corresponding <code>.xyz</code> file and, if found, it produces a <code>.vtf</code> file ready for visualizing with VMD.</p> <p>To use it, download the provided script called <code>out2charge</code>, put it in your <code>$PATH</code>, and run it on your output:</p> <pre><code>   out2charge ligand_2001.out\n</code></pre> <p>If everything goes well, you should see the following output:</p> <pre><code>   Charges were output to ligand_2001.charge.\n   The files ligand_2001.xyz and ligand_2001.charge will be used\n   to construct ligand_2001.vtf.\n   Load ligand_2001.vtf into VMD and select 'Coloring method -&gt; charge'.\n</code></pre> <p>Indeed, a new file <code>ligand_2001.charge</code> will be produced, containing the charges extracted from the <code>.out</code> file. These charges, together with the information in the <code>.xyz</code> file will be used to construct a <code>.vtf</code> file readable by VMD. Load this file into VMD:</p> <pre><code>   vmd ligand_2001.vtf\n</code></pre> <p>and go to <code>Graphics/Representation</code>. For <code>Drawing Method</code> choose <code>CPK</code> and for <code>Coloring Method</code> choose <code>Charge</code>. You will get a nice ball-and-stick model of your ligand, with the atoms coloured accorind to charge. In Fig.3 we show a comparison of the plots for the three ways of partitioning charge that we described earlier.</p> <p> </p>     Fig.3 Comparison of atomic charges on the ligand: Mulliken (left), NPA    (middle) and DDEC (right). Warm colours correspond to negative    charges. Visualization in VMD.    <p>This completes tutorial 8.</p> <p>Files for this tutorial:</p> <ul> <li>out2charge</li> <li>T8_files.zip</li> </ul> image/svg+xml <ol> <li> <p>D. R. Bowler, and T. Miyazaki, O(N) methods in electronic structure calculations, Reports on Progress in Physics, 75 (2012).\u00a0\u21a9</p> </li> <li> <p>J. Dziedzic, H. H. Helal, C.-K. Skylaris, A. A. Mostofi, and M. C. Payne, M. C., Minimal parameter implicit solvent model for ab initio electronic-structure calculations, EPL, 95 (2011).\u00a0\u21a9</p> </li> <li> <p>S. J. Fox, J. Dziedzic, T. Fox, C. S. Tautermann, and C.-K. Skylaris, Density functional theory calculations on entire proteins for free energies of binding: Application to a model polar binding ste, Proteins: Structure, Function and Bioinformatics, 82 (2014).\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>L. Gundelach, T. Fox, C. S. Tautermann, and C.-K. Skylaris, Protein\u2013ligand free energies of binding from full-protein DFT calculations: convergence and choice of exchange\u2013correlation functional, Physical Chemistry Chemical Physics, 23 (2021).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>T. A. Manz, and D. S. Sholl, Improved Atoms-in-Molecule Charge Partitioning Functional for Simultaneously Reproducing the Electrostatic Potential and Chemical States in Periodic and Nonperiodic Materials, Journal of Chemical Theory and Computation, 8 (2012).\u00a0\u21a9</p> </li> <li> <p>D. L. Mobley, and M. K. Gilson, Michael K., Predicting Binding Free Energies: Frontiers and Benchmarks, Annual Review of Biophysics, 46 (2017).\u00a0\u21a9</p> </li> <li> <p>J. C. A Prentice, J. Aarons, J. C. Womack, A. E. A. Allen, L. Andrinopoulos, L. Anton, R. A. Bell, A. Bhandari, G. A. Bramley, R. J. Charlton, R. J. Clements, D. J. Cole, G. Constantinescu, F. Corsetti, S. M. M. Dubois, K. K. B. Duff, J. M. Escartin, A. Greco, Q. Hill, L. P. Lee, E. Linscott, D. D. O'Regan, M. J. S. Phipps, L. E. Ratcliff, A. Ruiz Serrano, E. W. Tait, G. Teobaldi, V. Vitale, N. Yeung, T. J. Zuehlsdorff, J. Dziedzic, P. D. Haynes, N. D. M. Hine, A. A. Mostofi, M. C. Payne, and C.-K. Skylaris, The ONETEP linear-scaling density functional theory program, Journal of Chemical Physics, 152 (2020).\u00a0\u21a9</p> </li> <li> <p>K. A. Wilkinson, N. D. M. Hine, and C.-K. Skylaris, Hybrid MPI-OpenMP parallelism in the ONETEP linear-scaling electronic structure code: Application to the delamination of cellulose nanofibrils, Journal of Chemical Theory and Computation, 10 (2014).\u00a0\u21a9</p> </li> <li> <p>J. C. Womack, L. Anton, J. Dziedzic, P. J. Hasnip, M. I. J. Probert, and C.-K. Skylaris, DL-MG: A Parallel Multigrid Poisson and Poisson-Boltzmann Solver for Electronic Structure Calculations in Vacuum and Solution, Journal of Chemical Theory and Computation, 14 (2018).\u00a0\u21a9</p> </li> <li> <p>S. Genhenden, J. Kongsted, P. Soderhjelm, and U. Ryde, Nonpolar solvation free energies of protein-ligand complexes, Journal of Chemical Theory and Computation, 11 (2010).\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_9/tutorial/","title":"Tutorial 9","text":"image/svg+xml ONETEP Tutorials 7.0.0 Tutorial 9"},{"location":"tutorials/tutorial_9/tutorial/#tutorial-9-dftu-on-strongly-correlated-magnetic-materials-a-case-study-on-antiferromagnetic-hematite","title":"Tutorial 9: DFT+U on strongly correlated magnetic materials: A case study on antiferromagnetic Hematite","text":"<p> Version: all versions  Davide Sarpa</p>"},{"location":"tutorials/tutorial_9/tutorial/#introduction","title":"Introduction","text":"<p>The goal of the tutorial is to provide a working example on how it is possible to model strongly correlated magnetic materials applying DFT+U methods <sup>9</sup> <sup>10</sup> <sup>11</sup>. We will be working with hematite as an example of such materials but the method can be applied to a plethora of materials.</p>"},{"location":"tutorials/tutorial_9/tutorial/#hematite","title":"Hematite","text":"<p>Hematite is a blood-red iron oxide with formula \\(\\alpha-\\text{Fe}_2\\text{O}_3\\)  with a melting point of 1350 \u00b0C. It belongs to the hexagonal crystal family, in particular, it is a Ditrigonal scalenohedral with a \\(R\\bar{3}C\\) space group (167), sharing the same structure as corundum. The lattice parameters \\(a,b,c\\)  are \\(a=b=5.0356\\) \u212b and \\(c=13.7489\\) \u212b with 6 formula units per cell with a band gap of \\(1.9-2.2\\) eV. Its structure is an hpc anion stacking of \\(\\text{O}^{2-}\\) along the [001] direction with \\(\\text{Fe}^{3+}\\) occupying \\(2/3\\) of the interstitial octahedrical positions <sup>1</sup>. Below the N\u00e9el temperature (\\(T_N = 963 K\\)), \\(\\text{Fe}_2\\text{O}_3\\) is antiferromagnetic with weak ferromagnetism. The high-spin \\(d^5\\text{Fe}^{3+}\\)  cations within one bilayer in the (0001) planes are ferromagnetically coupled to each other while antiferromagnetically coupled to the adjacent Fe bilayers <sup>2</sup>. The magnetic moment is determined to be \\(4.6\\) \\(\\mu_{B}\\)  per atom. The upper edge of the valence band is dominated by oxygen p states, while the bottom of the conduction band is dominated by Fe d states. Hematite is generally considered to be a charge transfer rather than a Mott-Hubbard insulator <sup>3</sup> <sup>4</sup> <sup>5</sup>.</p> <p> </p> Fig.1: Primitive rhombohedral cell (left), Conventional hexagonal cell (right). Iron atoms in brown, oxygen in red."},{"location":"tutorials/tutorial_9/tutorial/#magnetism","title":"Magnetism","text":"<p>The weak ferromagnetism is due to spin-canting which is a relativistic effect. Luckily for us it is possible to obtain Hematite in an antiferromagnetic state with magnetic moments close to the experimental values by properly setting up the simulation without the need to include relativistic effects explicitly.</p> <p>If we consider the primitive hematite cell along the Z axis there are 3 possible different antiferromagnetic states:</p> <ul> <li>\\(+-+-\\) (up-down-up-down)</li> <li>\\(++--\\) (up-up-down-down)</li> <li>\\(+--+\\) (up-down-down-up)</li> </ul> <p>Out of all these states the last one (\\(+--+\\)) is the ground state, we would like to be able to force our system to end up Out of all these states the last one (\\(+--+\\)) is the ground state, we would like to be able to force our system to end up in the ground state.</p> <p> </p> Fig.2: Ground state antiferromagnetic state for hematite in primitive cell, Fe1 labels iron with up spin configuration, Fe2 for down spin configuration. <p>Magnetic systems are challenging to model due to the existence of very many different local minima which, in most cases, are very close in energy Forcing the system into a specific state may not be easy, but there are methods that can help us achieve what we want.</p>"},{"location":"tutorials/tutorial_9/tutorial/#dftu","title":"DFT+U","text":"<p>The problem of DFT to describe correlated systems can be attributed to the tendency of xc functionals to over-delocalize valence electrons and to over-stabilize metallic ground states, this prevents materials like Hematite to be described by DFT. LDA and GGA both predict hematite to be a metallic system and they also underestimate local magnetic moments. The reason behind this delocalization is rooted to the inability of the approximated xc to completely cancel out the electronic self-interaction contained in the Hartree term. The main advantage of the DFT+U method is that it is within the realm of DFT, thus does not require significant effort to be implemented in the existing DFT codes and its computational cost is only slightly higher than that of normal DFT computations.</p> <p>DFT+U treats the d and f orbitals as localised while keep the rest at the delocalised LDA/GGA level. In order to do that it projects the bands into localised orbitals and compute a new potential. The DFT+U method can be used to penalise the non-integer occupancy of these orbitals, tending to fill states with occupancy greater than 0.5 and empty states with occupancy less than 0.5.</p> \\[    \\hat{V}^{(\\sigma)}_{DFT+U} = \\sum_{I}  U^{(I)}\\lvert \\varphi_m^{(I)} \\rangle (\\frac{1}{2} \\delta_{m m'} - n^{(I) (\\sigma)}_{m m'})  \\langle\\varphi_{m'}^{(I)} \\rvert \\] <p>The U and J values are screened Coloumb and Exchange terms which are system and implementation dependent. In general, you are not able to plug and play an U or J value from the literature. What is usually done it's empirically testing different values (run multiple calculations with different combination of U and J) or most software (including ONETEP) have a linear response theory implementation to calculate the parameters from first principles <sup>8</sup> <sup>6</sup> <sup>7</sup>.</p>"},{"location":"tutorials/tutorial_9/tutorial/#setting-up-the-calculations","title":"Setting up the calculations","text":"<p>Now we start with the actual tutorial, we will setup a bulk hematite simulation where we apply a DFT+U correction on the d orbitals of the iron atom. We also have to label atoms based on their spin which allow us to assign different parameters for spin down and spin up Fe atoms. This will help us achieve the AFM state we are looking for. We will see what we should look out in an output and what are the interesting properties for this material.</p> <p>You will see that the cell and atoms we are using are neither from a primitive or a conventional cell, It is a orthogonal 3x2x1 supercell and this because orthogonal cell are easier to deal with and due to having 11 bohr radius NGWFs we need to have bigger cells.</p>"},{"location":"tutorials/tutorial_9/tutorial/#input-files","title":"Input files","text":"<p>ONETEP requires different files to work properly.</p> <ol> <li>A .dat file which contains all the information about your sytem (positions and cell) and the simulations parameters</li> <li>Pseudopotentials files, we will be using on the fly generated by CASTEP, but you could use your favourites.</li> </ol> <p>All the files needed for the simulation can be downloaded from:</p> <ul> <li>Fe_NCP19_PBE_OTF.usp</li> <li>O_NCP19_PBE_OTF.usp</li> <li>hematite.out</li> <li>hematite.dat</li> </ul>"},{"location":"tutorials/tutorial_9/tutorial/#dat","title":"Dat","text":"<p>The first two blocks are the cell and atoms positions. You might see that iron atoms are labelled Fe1 or Fe2 depending if they will be treated as spin up atoms or spin down atoms.</p> <p>The third block is <pre><code>%BLOCK SPECIES\n  Fe1 Fe 26 13 11.000000\n  Fe2 Fe 26 13 11.000000\n  O O 8 4 11.000000\n%ENDBLOCK SPECIES\n</code></pre> This block tells us which atom type we should assing to Fe1, Fe2, and O, their atomic number and how many NGWFS we should use for each atom type as well as their radius. For strongly correlated systems NGWFs radius of 11.00 bohr is suggested. The next block is <pre><code>%BLOCK SPECIES_ATOMIC_SET\n  Fe1 \"SOLVE conf=3s2 3p6 3d5 4s0 4p0 SPIN=+5 CHARGE=+3\"\n  Fe2 \"SOLVE conf=3s2 3p6 3d5 4s0 4p0 SPIN=-5 CHARGE=+3\"\n  O  \"SOLVE INIT SPIN=0 CHARGE=-1\"\n%ENDBLOCK SPECIES_ATOMIC_SET\n</code></pre> This block setup the initial configurations for the atoms. Fe1 and Fe2 atoms will have a charge of +3 and a spin of + or - 5. We have also setup the electronic configurations. The atomic solver generates the first guess for the density kernel for the first scf iteration, it does it by calculating the atomic density.</p> <p>The next block is the Hubbard block where we setup the DFT+U parameters <pre><code>%block hubbard\n  Fe1 2 6.0 0.0 -10.0 0.00 5.0\n  Fe2 2 6.0 0.0 -10.0 0.00 -5.0\n%endblock hubbard\n</code></pre> In this block we setup on the d (l=2) orbitals a U value of 6 the rest are the default parameters except the last column (5,-5). The last column is the spin-splitting functionality that help certain system to break the spin symmetry in AFM configurations.</p> <p>The rest of the blocks are to tell ONETEP for which atom types it has to compute the ldos and dos. Related to this functionality we also have to paratemers called dos_smear and pdos_max_l. The First relates to the gaussian smearing applied to the dos and the max l quantum number to compute the pdos for.</p> <p>The rest of the parameters are self-explanatory with some exception such as maxit_palser_mano and maxit_hotelling which are related to the diagonalisation library.</p> <p>If require more explanation you can refer to the ONETEP keyword database.</p>"},{"location":"tutorials/tutorial_9/tutorial/#pseudopotentials","title":"Pseudopotentials","text":"<p>It is important to know is that the number of NGWFs depends on your Pseudopotentials. If you use your own be sure to modify them.</p>"},{"location":"tutorials/tutorial_9/tutorial/#evaluating-the-outputs","title":"Evaluating the outputs","text":"<p>ONETEP will generate many files based on we configured the calculations, but for this tutorial we will be focusing on few ones.</p> <ul> <li><code>.out</code>: the main output file</li> <li><code>DOS.txt</code>: Density of states file</li> <li><code>LDOS.txt</code>: Local density of states file</li> <li><code>PDOS.txt</code>: Partial density of states file</li> <li><code>spindensity.cube</code>: Cube file necessary to visualise the spin density</li> </ul>"},{"location":"tutorials/tutorial_9/tutorial/#what-to-look-for-in-the-main-output-file","title":"What to look for in the main output file","text":"<p>First thing is to check is the whether the atoms are in the configuration you wanted to (in our case a \\(\\text{Fe}^{3+}\\) with spin UP or DOWN). This can be seen by looking for this block for each atom (shown here the down Fe atom) <pre><code>Config String: 3s2 3p6 3d5 4s0 4p0 SPIN=-5 CHARGE=+3\nOrbitals (num,occ):  5     2.00 6.00 5.00 0.00 0.00\nOrbitals   (num,l):  5        0    1    2    0    1\n</code></pre> As you can see it was properly set as we have the occupancies as we wanted them to be</p> <p>The second step is, as explained in the DFT+U part, the occupancies for the majority spin (either UP or DOWN for different Fe atoms) has to be \\(&gt; 0.5\\) while \\(&lt; 0.5\\) for the minority spin. This is very important to allow DFT+U to do its job and it can be checked in the following table by looking at the diagonal elements.</p> <pre><code>#################################################################\nDFT+U information on atom      1 of Hubbard species Fe1\n#################################################################\nOccupancy matrix of Hubbard site      1 and spin      1 is\n   m_l =   -2          -1           0           1           2\n   0.98677750  0.00064944  0.00008254 -0.00024296 -0.00055787\n   0.00064545  0.99097329 -0.00010565  0.00019818  0.00042874\n   0.00006971 -0.00009587  0.97935271  0.00006742  0.00560449\n   -0.00024459  0.00020075  0.00009975  0.99062614 -0.00144761\n   -0.00055154  0.00042561  0.00602074 -0.00142407  0.96101391\n#################################################################\nOccupancy matrix of Hubbard site      1 and spin      2 is\n   m_l =   -2          -1           0           1           2\n   0.17854088 -0.10543254 -0.00014018 -0.01900359 -0.00209684\n   -0.10478392  0.27925352 -0.00100259  0.00081665 -0.01300318\n   -0.00018286 -0.00127346  0.07647309  0.00442738  0.00630459\n   -0.01913097  0.00082721  0.00279433  0.25746916  0.08014266\n   -0.00208260 -0.01299767  0.00576137  0.07901457  0.10302424\n#################################################################\nTotal occupancy of Hubbard site      1 is         5.80350444 e\nLocal magnetic moment of Hubbard site      1 is   4.01398264 mu_B\nDFT+U energy of Hubbard site      1 is            0.08324891 Ha\n#################################################################\n</code></pre> <p>Another important thing to check are the bands occupancies. Hematite is a semiconductor with a 2 eV band gap, we would then expect to have fully occupied bands and unoccupied virtual bands. If we were to treat it as a metal we could expect fractional occupancies occurring, but that would be physically wrong for our system.</p> <p>If you look at the band occupancies for both spin up and down, you can see that we indeed obtain fully occupied bands and unoccupied bands. This reassure us that the structure we obtained is chemically and physically sensible. The small number you see in the \"unoccupied\" bands is due to numerical errors.</p> <p>This is for spin 1 (up)</p> <pre><code>Orbital | Energy (Eh) | Occupancy\n\n1    -3.063849888   1.0000000\n.......   ...........   .........\n1791     0.357172741   0.9999996\n1792     0.357225976   0.9999996\n1793     0.357724185   0.9999996\n1794     0.357733628   0.9999996\n1795     0.358380935   0.9999997\n1796     0.358393032   0.9999997\n1797     0.360316821   0.9999996\n1798     0.360327604   0.9999996\n1799     0.366378308   0.9999993\n1800     0.366387961   0.9999993\n....... -- gap at 0K -- .........\n1801     0.438702297   0.0000005\n1802     0.438704363   0.0000005\n1803     0.438802525   0.0000005\n1804     0.438803496   0.0000005\n</code></pre> <p>This is for spin 2 (down)</p> <pre><code>Orbital | Energy (Eh) | Occupancy\n1    -3.062779703   1.0000000\n.......   ...........   .........\n1791     0.357161543   0.9999996\n1792     0.357225094   0.9999996\n1793     0.357691641   0.9999996\n1794     0.357691940   0.9999996\n1795     0.358354526   0.9999997\n1796     0.358355045   0.9999997\n1797     0.360301824   0.9999996\n1798     0.360302485   0.9999996\n1799     0.366369520   0.9999993\n1800     0.366387326   0.9999993\n....... -- gap at 0K -- .........\n1801     0.438975662   0.0000005\n1802     0.438982779   0.0000005\n1803     0.439082674   0.0000005\n1804     0.439094865   0.0000005\n</code></pre> <p>And as last we should also check that we obtain a band gap and its value is close to experiment. This can be seen from the output by looking for these lines.</p> <p>Why do we get two band gaps? Because we are studying a magnetic system, we get a band gap for each spin channel and for an AFM material the bandgap should be the same (numerical errors aside).</p> <pre><code>HOMO-LUMO gap:       0.072314337 Eh\nHOMO-LUMO gap:       0.072588336 Eh\n</code></pre>"},{"location":"tutorials/tutorial_9/tutorial/#dos-and-pdos","title":"DOS and PDOS","text":"<p>Next step is to plot the density of states. It will tell us the distribution of electrons and states in our system we would expect to have gap around 0 of about 2 eV as this is the band gap of the material.</p> <p></p> <p>We indeed obtain a gap between the states but it does not tell us much more. To obtain more information we will be plotting the local density of states (LDOS) and the partial density of states (PDOS).</p> <p> </p> <p>From the local density of states we can immediately notice that the lowest lying bands in the plot are mostly made of Fe1 bands but, this is very important, the top of the valence band is made mostly by O bands. The bottom of the conduction band is made of Fe2 orbitals. This allow us to classify hematite as a charge transfer insulator between the oxygen and the iron atoms. What if we would like to know which atomic orbitals contribute the most in this charge transfering? We need to plot the PDOS.</p> <p>It will project the bands into the atomic components, in this way, as you can see in the graph the top of the valence band is dominated by O 2p states while the bottom of the conduction band by Fe2 3d states.</p>"},{"location":"tutorials/tutorial_9/tutorial/#mulliken-population-analysis","title":"Mulliken population analysis","text":"<p>The Mulliken population analysis is a very good tool to understand if our system is behaving correctly. In an AFM material the total spin should be 0 and the local spin should be the same for the same atoms. In this case we have two different types The spin up and down Fe atoms. The absolute value of the local spin should be the same with just different signs.</p> <p>The material is also charge neutral and we would expect that the similar atoms should carry similar charges.</p> Species Ion Total Charge (e) Spin (hbar) 0 1 6.906 -0.906 0.01 0 2 6.906 -0.906 0.01 0 3 6.906 -0.906 -0.01 0 4 6.905 -0.905 -0.01 0 5 6.906 -0.906 -0.00 0 6 6.907 -0.907 -0.00 Fe 7 14.641 1.359 2.20 Fe 8 14.641 1.359 2.20 Fe 9 14.641 1.359 -2.20 Fe 10 14.641 1.359 -2.20 <p>As you can see from this snapshot we do indeed obtain the same charge and same spin for all similar atoms as we would expect.</p>"},{"location":"tutorials/tutorial_9/tutorial/#spin-density","title":"Spin Density","text":"<p>Now it is time to visualise the spin density which is the total electron density of electrons of one spin minus the total electron density of the electrons of the other spin. We would like to visualise it to know if we obtained the afm state we wanted, the up-down-down-up configuration.</p> <p>You can directly open and visualise The .cube generated at the end of the calculations with VESTA, VMD or lots of other softwares.</p> <p> </p> Fig.3: Hematite spin density, blu spheres refers to atom with up spin and yellow to down spin <p>You can see from the picture that we did get the AFM states with +--+ configuration as we wanted.</p>"},{"location":"tutorials/tutorial_9/tutorial/#what-to-do-next","title":"What to do next","text":"<p>The tutorial is now complete, but you could still move forward. What can you do next?</p> <p>ONETEP outputs many. more information than the one showed you here.</p> <p>You can plot</p> <ul> <li>The electrostatic potential</li> <li>The orbitals</li> <li>The electron density</li> <li>The band plot</li> </ul> <p>You can then relax the structure and recompute the properties to see what changed and how.</p> <p>We have chosen to use U=6, but you could try different U values and see how it affects the system.</p> image/svg+xml <ol> <li> <p>R.M.Cornell et al, in The Iron Oxides, John Wiley &amp; Sons, Ltd, 2003, pp. 9-38.\u00a0\u21a9</p> </li> <li> <p>G.S.Parkinson, Surface Science Reports, vol. 71, no. 1, pp. 272\u2013365, 1 Mar. 1, 2016.\u00a0\u21a9</p> </li> <li> <p>Naveas M. et al, iScience 26, 106033, February 17, 2023.\u00a0\u21a9</p> </li> <li> <p>Huang X. et al,  J.Phys.Chem C 2016,  120, 4919-4930.\u00a0\u21a9</p> </li> <li> <p>Si et al, J. Chem. Phys. 152, 024706 (2020).\u00a0\u21a9</p> </li> <li> <p>D.D.O\u2019Regan, N. D. M. Hine, M. C. Payne and A. A. Mostofi, Phys. Rev. B 85, 085107 (2012).\u00a0\u21a9</p> </li> <li> <p>M.Cococcioni and S. de Gironcoli, Phys. Rev. B 71, 035105 (2005).\u00a0\u21a9</p> </li> <li> <p>D.D.O\u2019Regan, N. D. M. Hine, M. C. Payne and A. A. Mostofi, Phys. Rev. B 82, 081102 (2010).\u00a0\u21a9</p> </li> <li> <p>J.Z.V.I. Anisimov and O. K. Andersen, Phys. Rev. B 44, 943 (1991).\u00a0\u21a9</p> </li> <li> <p>V.I. Anisimov, F. Aryasetiawan, and A. I. Liechtenstein, J. Phys.: Condens. Matter 9, 767 (1997).\u00a0\u21a9</p> </li> <li> <p>S.L. Dudarev, Phys. Rev. B 57, 3 (1998).\u00a0\u21a9</p> </li> </ol>"}]}